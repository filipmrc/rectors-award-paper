\documentclass[times, utf8, diplomski, numeric]{fer}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgf-umlsd}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{bm}
\usepackage[]{mcode}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{subcaption}
\usepackage[font = footnotesize]{caption}
\usepackage{fancyhdr}
\usetikzlibrary{shapes,arrows}
\graphicspath{ {images/} }

\begin{document}
\renewcommand{\labelitemi}{$\bullet$}
\tikzstyle{block} = [draw, fill=white!20, rectangle,
    minimum height=2em, minimum width=4em]
\tikzstyle{block2} = [draw, fill=white!20, rectangle, 
    minimum height=0.1em, minimum width=0.1em]    
\tikzstyle{block_small} = [draw, fill=white!20, rectangle, 
    minimum height=2em, minimum width=2em]
\tikzstyle{sum} = [draw, fill=white!20, circle, node distance=2cm]
\tikzstyle{input} = [coordinate]
\tikzstyle{output} = [coordinate]
\tikzstyle{pinstyle} = [pin edge={to-,thin,black}]

% TODO: Navedite broj rada.
%\thesisnumber{3962}

% TODO: Navedite naslov rada.
\title{Intuitivni sustav teleoperacije robotskog manipulatora korištenjem RGB-Dubinske kamere}

% TODO: Navedite vaše ime i prezime.
\author{Filip Marić \\ Ivan Jurin}

\maketitle

% Dodavanje zahvale ili prazne stranice. Ako ne želite dodati zahvalu, naredbu ostavite radi prazne stranice.
\zahvala{Ovaj rad izrađen je na Fakultetu elektrotehnike i računarstva
Sveučilišta u Zagrebu pod vodstvom prof. dr. sc. Ivana Petrovića i prof.
dr. sc. Zorana Kalafatića i predan je na natječaj za dodjelu Rektorove
nagrade u akademskoj godini 2015./2016. \\ \\ Posebno se zahvaljujemo dr. sc. Ivanu Markoviću na podršci i savjetovanju.}

\tableofcontents

\chapter{Uvod}
Klasična upravljačka sučelja za robotske manipulatore kao što su tipkovnice ili daljinski upravljači u uporabi su od samih početaka razvoja robotike.
Kao pozitivna zajednička karakteristika ovih sučelja mogla bi se navesti njihova jednostavnost izvedbe: stisak odgovarajuće kombinacije tipki ili guranje kontrolne palice uzrokuje neku radnju manipulatora.
Dok su se ovakva sučelja pokazala efektivnim i cijenovno povoljnim rješenjem za ustaljene uloge robotskih manipulatora u industriji, njihov učinak u novijim primjenama ostavlja prostora za drugačije pristupe.

Zahvaljujući masovnoj proizvodnji tehnologija koje su za početka razvoja robotike bile u povojima, danas je prostor za razvoj inovativnih pristupa upravljačkim sučeljima veći nego ikad.
Robotski manipulatori vrlo su često anatomski slični ljudskoj ruci, što nas je dovelo do zaključka kako bi upravljanje manipulatora ljudskom rukom rezultiralo visokom razinom intuitivnosti, čiji manjak smatramo glavnim nedostatkom klasičnih sučelja.

Zamišljeno upravljačko sučelje razlikuje se od klasičnih po još jednoj osnovnoj karakteristici: ne zahtjeva kontakt između opreme i korisnika.
Ovakav sustav ostvarujemo snimanjem pokreta ruke korisnika pomoću 3d kamere, koja uz sve funkcije standardne kamere vraća informaciju o udaljenosti objekata u kadru.
Dobivene informacije obrađuju se razvijenim algoritmom detekcije dlana ruke te se šalju preko mreže na upravljačko računalo robotskog manipulatora, koje ih pretvara u naredbe.

%doradi zadnji paragraf, bolje primjene, fokusirati se više na potrebu za ljudskim aspektom i postupnim ulaskom robota u svakodnevni život
Ovakvim upravljanjem dobivamo prirodnije kretanje robotskih manipulatora, što će postupnim ulaskom robota u svakodnevni život postati tražena karakteristika.
U industriji zabave jedna moguća primjena je pomicanje kamere na kraju više-osnog manipulatora, gdje ovakvo upravljanje omogućuje intuitivniju kontrolu kadra od strane snimatelja.
Svemirske agencije i robotički laboratoriji diljem svijeta već su duže vrijeme fokusirani na ovakav pristup problemu upravljanja robota u orbitalnim postajama \cite{yoshida2009achievements} \cite{larson1999human}, gdje klasična sučelja zakazuju zbog pobjega tereta.
Ljudima s poteškoćama u kretanju robotska ruka upravljana ovakvom metodom može olakšati dohvaćanje objekata u okolini, pritom dajući obavljanju zadataka ljudsku dimenziju koja je pri uporabi ovakvih pomagala bitna.

U poglavlju "Opći i specifični ciljevi rada" definiramo zadatke, zahtjeve i okvirnu strukturu upravljačkog sučelja koje razvijamo.
Poglavlja "Sklopovska podrška" i "Programska podrška" opisuju sklopovlje i programske alate sa više ili manje detalja, ovisno o važnosti i frekvenciji pojavljivanja pojedine komponente u sustavu.
Posebno se zadržavamo na opisu ROS operacijskog sustava i pratećih paketa, koji čine centralnu komponentu sustava i povezuju sve ostalo.

Teoretsku pozadinu problema kretanja manipulatora i prijedlog rješenja obrađujemo u poglavlju "Kinematika manipulatora".
Predloženo rješenje u ovom poglavlju također programski provjeravamo na razini matematičke ispravnosti.
Problem detekcije stanja ljudske ruke obrađen je u poglavlju "Detekcija", gdje izlažemo dvije metode i uspoređujemo njihove performanse.

Nakon što smo pojedinačno objasnili komponente koje sačinjavaju sustav, njihovu povezanost i detalje programske izvedbe izlažemo u poglavlju "Sustav upravljanja".
U istom poglavlju izlažemo rezultate testiranja sustava na simulaciji robotske ruke, kako bi dobili uvid u moguće nedostatke sustava.
Konačno, izlažemo rezultate dobivene korištenjem stvarnog manipulatora te zaključujemo rad.

\chapter{Opći i specifični ciljevi rada}
Opći cilj našeg rada je razvoj upravljačkog sučelja koje kao ulaznu informaciju koristi isključivo gestikulacije i pomake ruke korisnika.
Zamišljeno sučelje mora biti jednostavno za savladati novom korisniku, intuitivno , pružiti odgovarajuću razinu preciznosti i pri tome zadržati relativno nisku cijenu.
Iz ovih smjernica proizlaze specifični ciljevi rada:
\begin{itemize}
\item Cijeli sustav mora biti izveden koristeći besplatne, open-source\footnote{\textbf{open-source} - čiji je izvorni kod i/ili nacrti (dizajn) dostupan javnosti na uvid, korištenje, izmjene i daljnje raspačavanje} tehnologije. 
Ovime osiguravamo ažurnost sustava kroz vrijeme te jednostavnije popravke i modifikacije.
\item Radi nedostatka open-source rješenja za detekciju ruke korištenom 3d kamerom, potrebno je razviti detekcijski algoritam koji uzima u obzir ograničenja korištene sklopovske podrške i potrebe sustava.
\item Udaljeno upravljanje zahtjeva korištenje robotskog operacijskog sustava ROS, u kojem izvodimo cijelokupni upravljački algoritam.
\item Sustav mora biti primjenjiv na bilo kojem manipulatoru sa 3 ili više osi. Ovo ukazuje na potrebu za programskim rješavanjem problema kinematike robota uz dostupnu opisnu datoteku i kompatibilnost sa najčešćim izvedbama ROS-API\footnote{\textbf{API} (\textit{engl. application programming interface}) - set programskih "blokova" razvijen sa svrhom olakšavanja komunikacije i upravljanja programskim ili sklopovskim sustavom} sučelja.
\item Sustav mora imati zadovoljavajuće dinamičko ponašanje, što zahtjeva testiranje kinematike i upravljačke petlje na simulaciji razvijenoj za potrebe rada.
\end{itemize}

Kako bi ostvarili ove ciljeve bilo je potrebno savladati metodologiju korištenja nekolicine programskih paketa i biblioteka, kao i riješiti problem međusobne kompatibilnosti brojnih komponenti sustava.
Komponente je potom potrebno uklopiti u strukturu upravljačke petlje više razine, pri tome vodeći računa o radnim frekvencijama korištenih sklopova.

%\section{Osnovni koncepti}
%%detaljan opis kako funkcioniraju "oba" načina upravljanja, eventualno ubaciti cardboard slike, slike upravljanja, slike detekcija gui, slike cijelokupnog sustava
%U ovom poglavlju opisujemo zamišljeno upravljačko sučelje.
%Prvi odlomak opisuje dva načina kojima upravljački algoritam bilježi kretnje ruke korisnika.
%Drugi odlomak sadrži grubi pregled arhitekture cjelokupnog sustava i svrhe pojedinih komponenata, koje detaljnije obrađujemo u poglavlju \ref{Upravljački algoritam}.

\section{Interpretacija pokreta}\label{2_1}
Samom prenošenju kretnji ljudske ruke na robota pristupili smo na dva načina: prvi ostvaruje praćenje ljudske ruke u stvarnom vremenu, dok se drugi bazira na načelu sličnom upravljanju kontrolnom palicom (\textit{engl. joystick}).

Praćenje ljudske ruke ostvarujemo "poistovjećivanjem" dlana korisnika s alatom na vrhu manipulatora. 
Pri početku upravljanja ljudska se ruka nalazi na sredini kadra i odgovarajućoj udaljenosti, ova početna pozicija poistovjećuje se sa trenutnom pozicijom alata manipulatora.
Pomicanjem dlana korisnik pomiče željenu poziciju alata manipulatora.
Upravljačka petlja "primjećuje" ovu razliku te regulacijom brzine zglobova ili izvršnog člana nastoji smanjiti pogrešku između trenutne i željene pozicije manipulatora.

Izvedba \textit{joystick} načina rada oko početne pozicije korisnikove ruke formira sferu promjera ovisnog o veličini dlana.
Zadržavanjem dlana korisnika unutar kugle, upravljački algoritam zadržava izvršni član u trenutnoj poziciji.
Pomicanjem dlana korisnika izvan sfere, upravljački algoritam pomiče vrh manipulatora u smjeru vektora razlike pozicija dlana od središta kugle.
%\begin{figure}
%\centering
%\includegraphics[scale=0.3]{koncept21}
%\includegraphics[scale=0.3]{koncept22}
%\caption{Prikaz \textit{joystick} načina upravljanja.}
%\end{figure}
Dva navedena pristupa svojom funkcionalnošću podređeni su ograničenjima detekcije i izvođenju u stvarnom vremenu.
Velika prednost razvijene detekcije leži u činjenici da se prati samo ljudska šaka te konkretno prenošenje kretnji na zglobove robota ne ovisi o ruci korisnika.
Prenosi se samo konačni "cilj" kretanja, dok se način postizanja prilagođava građi manipulatora.

Zajednička funkcija kod ovih pristupa vezana je uz otvaranje i zatvaranje alata (izvršnog člana).
Otvaranje šake korisnika upravljački algoritam interpretira kao naredbu otvaranja alata manipulaotra, dok se zatvorena šaka interpretira kao naredba zatvaranja.
Ova funkcija naravno ovisi o tipu alata na kraju manipulatora, no mapiranje otvaranja i zatvaranja šake na neku drugu funkciju ne predstavlja problem radi separabilnosti dijela upravljačke petlje vezane uz izvršni član.
U ovom radu većinom ćemo se baviti prvim i složenijim načinom upravljanja, jer svi sustavi razvijeni za njega mogu ostvariti \textit{joystick} način rada.



\section{Struktura sustava upravljanja}
Sustav upravljanja na najvišoj se razini sastoji od 4 komponente:
\begin{itemize}
  \item \textbf{Detektor} Na dubinskoj RGBD slici pronalazi dlan korisnika i prostorne koordinate (i orijentaciju) njegove sredine. 
  \item \textbf{Regulator} Interpretira razliku trenutne pozicije (i orijentacije) dlana i izvršnog člana manipulatora. 
  Rezultat se pretvara u potrban zakret (ili brzinu zakreta) zglobova manipulatora, nakon čega se šalje u API sučelje.
  \item  \textbf{API sučelje} Prima upravljačku naredbu i nakon obrade je prosljeđuje na nižu razinu gdje se pretvara u API naredbu.
  U istom ciklusu API sučelje čita trenutna stanja zglobova manipulatora i šalje ih natrag prema regulatoru.
  \item  \textbf{Manipulator} Prima API naredbu te je pretvara u konkretna kretanja zglobova. 
  Ugrađeno sklopovlje bilježi senzorska očitanja sa zglobova te ih priprema za čitanje od strane API sučelja.
\end{itemize}

Kako bi kvalitetno ostvarili koncepte upravljanja navedene u potpoglavlju \ref{2_1}, vrlo nam je bitna povratna veza prikazana na slici \ref{izvedba}.
Povratna veza omogućuje nam uvid u trenutno stanje sustava čime se omogućuje ispravljanje pogrešaka, praćenje referentne veličine i otpornost na smetnje.
Pomoću informacija o poziciji pojedinačnih zglobova također osvježavamo matricu Jakobijana manipulatora, koja je ključni element općeg kinematičkog rješenja praćenja u poglavlju \ref{direkt i inverz}.

\begin{figure}[!h]
\centering
\begin{tikzpicture}[auto, node distance=3cm,>=latex']
    % We start by placing the blocks
    \node [block] (detekcija) {{\small Detektor}};
    \node [block, right of=detekcija] (Regulator) {{\small Regulator}};
    \node [block, right of=Regulator, node distance=3cm] (system) {{\small API sučelje}};
    % We draw an edge between the controller and system block to 
    % calculate the coordinate u. We need it to place the measurement block. 
    \draw [->] (Regulator) -- node[name=u] {} (system);
    \node [output, right of=system, node distance=3cm] (output) {};
    \node [block, below of=system, node distance=2cm] (measurements) {{\small Manipulator}};

    % Once the nodes are placed, connecting them is easy. 
    \draw [->] (detekcija) -- node {} (Regulator);
    \draw [->] (system) -- node [name=y] {}(output);
    \draw [->] (y) |- (measurements);
    \draw [->] (measurements) -| node[pos=0.99] {} 
        node [near end] {} (Regulator);
\end{tikzpicture}
\caption{Blok dijagram izvedbe sustava}\label{izvedba}
\end{figure}

\subsubsection{Detektor}
Zahtjevi postavljeni na detektor relativno su niski. 
Radna frekvencija trebala bi biti dovoljno visoka da pri prosječnom gibanju referentne veličine bivaju zadane prije no što ih manipulator može sustići kako bi izbjegli oscilacije.
Minimalni zahtjev na sam detekcijski algoritam jest mogućnost pronalaženja koordinata ljudskog dlana u barem dvije dimenzije, ovime se omogućava kretanje manipulatora po ravnini.
U našem radu izvedeno je trodimenzionalno translacijsko kretanje, dok je upravljačka petlja potpuno osposobljena za detekciju punih 6 stupnjeva slobode gibanja.

\subsubsection{Regulator}
Pod pojmom regulator ovdje se podrazumjeva cijela programska struktura koja prima, obrađuje i šalje podatke između više objekata u stvarnom vremenu.
Stvarnu strukturu regulatora detaljnije ćemo razmotriti u poglavlju \ref{Upravljački algoritam}, kada se upoznamo sa korištenom programskom podrškom i kinematičkim rješenjem.

Ovdje ćemo samo napomenuti da je za kvalitetan rad regulatora bitna sinkronizacija rada svih njegovih komponenti kako bi se ostvario stabilan protok podataka i stalna radna frekvencija sustava.
Ovo je ostvarujemo koristeći mrežnu arhitekturu operacijskog sustava ROS, koji omogućuje određivanje radne frekvencije komponenti i daje detaljan uvid u protok podataka.
Također, mrežna arhitektura ROS-a omogućuje pokretanje komponenti pojedinačno na različitim fizičkim računalima, što ide u prilog modularnosti sustava.

\subsubsection{API sučelje}
Općenitost sustava zahtjeva razdvajanje općih funkcija za regulaciju i obradu podataka od funkcija povezanih uz specifični korišteni manipulator.
Konkretnije, ovu komponentu moramo ostvariti tako da se na nju može spojiti API bilo kojeg manipulatora koji zadovoljava fizičke zahtjeve.

Paket \texttt{ros\_control}ostvaruje zadano sučelje koristeći apstraktne klase na koje "spajamo" API manipulatora.
Dovoljno je funkcije čitanja stanja zglobova i zadavanja brzine/pozicije "umotati" u dostupne klase, te ostatak sustava izvesti koristeći njih.

\subsubsection{Manipulator}
Manipulator je robotski uređaj koji izvršava željenu radnju te je na njega postavljeno nekoliko osnovnih zahtjeva kako bi bio kompatibilan sa sustavom.
Kao što je ranije spomenuto, sam manipulator mora imati minimalno dva računalom upravljiva stupnja slobode (time ostvarujemo planarno kretanje).
Također, manipulator mora biti opermljen senzorima pozicije i/ili brzine koje je moguće čitati na računalu koristeći API.

\chapter{Sklopovska podrška}
Sustav je dizajniran da bude univerzalan s obzirom na manipulator i detekcijski uređaj, ali pri svim testiranjima koristili smo Kinova Jaco robotsku ruku i Microsoft Kinect 3d kameru.
\section{Microsoft Kinect 3d kamera}
[//TODO slika Kinecta]
Moderni senzori su u mogućnosti prikazati sliku uz submilimetarsku preciznost. Takvu preciznost nam ne nudi Kinect, ali nudi sasvim prihvatljivu preciznost od nekoliko milimetara (ovisno o udaljenosti objekta).

Kinect je naziv za liniju Microsoftovih senzora pokreta razvijenih primarno za potrebe igraćih konzola, ali u širokoj uporabi u području računalnog vida. Sastoji se od dubinske kamere, klasične kamere te niza mikrofona pomoću kojih je u mogućnosti izvršavati kompleksne zadatke prepoznavanja i praćenja kao što je praćenje ljudskih pokreta.

U ovom radu je korišten \textit{Kinect for Xbox 360} \cite{kinect} te se ne razmatraju parametri drugih Kinect senzora.

Dubinska kamera se sastoji od emitera infracrvene svjetlosti koji projicira pseudoslučajne uzorke točaka u Kinectov vidokrug. Infracrvena kamera koja se nalazi na znanoj udaljenosti snimi položaj točaka, po kodiranom uzorku zna pod kojim kutom je uzorak generiran te jednostavnom triangulacijom izračuna dubinu u danoj točki prostora. Kako postoji određena udaljenost između senzora i emitera, na nekim mjestima Kinect neće biti sposoban odrediti dubinu zbog okluzije (Slika \ref{fig:oculsion}).

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\textwidth]{detekcija/okluzija}
	\caption{Okluzija u dubinskoj slici}
	\label{fig:oculsion}
\end{figure}

Okluzija se pojavljuje kao posljedica razmaka između emitera infracrvene svjetlosti i kamere. Kako kamera promatra prostor s neke udaljenosti od emitera, vidi neke dijelove prostora koje emiter nije mogao obasjati jer su bili pokriveni drugim objektima. Tako na slici \ref{fig:oculsion} bijelom bojom vidimo sjenu koju dubinska slika ruke ostavlja za sobom. Iz položaja sjene i ruke jasno se vidi kako emiter emitira infracrvenu svjetlost s desne strane kamere što i je slučaj ako pogledamo arhitekturu senzora gdje se emiter nalazi s desne strane.

Okluzije predstavljaju znatni problem u detektiranjima. U detekciji dlana, dlan može biti u takvom položaju da jedan dio dlana zasjeni drugi te ćemo dobiti maksimalnu moguću dubinu na tom području. Takvi slučajevi mogu prevariti detektor te zato valja imati na umu učinak okluzije prilikom konstrukcije detektora.

Jedan kvalitetan pristup detekciji dlana koristi sintetizirane slike dlana na kojima simulira i okluziju kako bi detektor bio što bolje naučen na prave slike \citep{xu2013efficient}. U istom radu Xu i Cheng su simulirali i neuspješne detekcije malih površina. Jedan takav primjer vidimo na slici \ref{fig:loss-of-little-objects}, gdje je kažiprst okrenut u smjeru kamere te ne uspijeva biti detektiran. Razlog takvih neuspješnih detekcija nalazimo u načinu na koji Kinect određuje kut pod kojim je površina obasjana. Kako je već spomenuto, Kinect generira pseudoslučajne uzorke ovisno o kutu pod kojim su oni projicirani te tako kamera uspoređivanjem uzoraka može znati pod kojim kutom je predmet obasjan. Ako je predmet dovoljno male površine, uzorak neće biti potpun. Kinect pri tome pristupa na isti način kao i kod okluzije, dubinu na tom području postavlja na maksimalnu moguću dubinu.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\textwidth]{detekcija/gubitak-malih-objekata}
	\caption{Gubitak malih objekata}
	\label{fig:loss-of-little-objects}
\end{figure}

\newpage
\section{Kinova Jaco robotska ruka}
Kinova Jaco (\ref{JACO2}) robotska je ruka namijenjena osobama s poteškoćama u kretanju.
Jaco 2010. godine na tržište je stavlja kanadska tvrka Kinova robotics s ciljem olakšavanja svakodnevnog života korisnika.
Manipulator ima 6 stupnjeva slobode, čime se ostvaruje puna sloboda pozicioniranja alata u prostoru.
Alat se sastoji od grabilice sa 3 prsta, što omgućuje stabilne hvatove velike količine svakodnevnih objekata.
Ruka je dizajnirana kako bi bila kompatibilna sa raznim dostupnim električnim invalidskim kolicima, ali je zbog svoje kvalitetne izrade i specifikacija našla široku primjenu u znanosti.

\begin{figure}[h!]
\centering
\includegraphics[width = 0.7\textwidth]{JACO2}
\caption{Kinova Jaco robotska ruka} \label{JACO2}
\end{figure}

\subsection{Tehničke specifikacije}
Glavne prednosti Jaco robotske ruke su relativno niska potrošnja električne energije i malena masa komponenata.
Aktuatori na zglobovima opremljeni su raznim senzorima kroz koje korisnik može dobiti veliku količinu povratnih informacija o stanju manipulatora.


\subsubsection{Opće specifikacije}
Potrebni ulazni napon kreće se od 18V do 29V,  a to su vrijednosti lako ostvarive baterijom ugradivom u električna invalidska kolica.
Masa od 5.6 kg osigurava jednostavnu montažu i sigurnost pri upravljanju, što je također vrlo bitno za primarnu svrhu ove robotske ruke.
Detaljan prikaz općih specifikacija manipulaotra nalazi se u tablici \ref{jaco_spec}.

\begin{table}[h!]
    \centering
    \begin{tabular}{ | l | l | l |}
    \hline
    Masa & $5.6 \pm 5\%$ [kg] \\ \hline
    Ulazni napon  & $18 - 29$ [VDC] \\ \hline
    Ulazna struja & $2 - 10$ [A] \\ \hline
    Srednja snaga & $40$ [W] \\ \hline
    Frekvencija upravljanja & $100$ [Hz] \\ \hline
    Max. teret na alatu pri srednjoj ispruženosti & $1.5$  [kg]  \\ \hline
    Max. teret na alatu pri maksimalnoj ispruženosti  & $1$ [kg]\\ \hline
    Dohvat & $90$  [cm] \\ \hline
    Linearna brzina alata & $5 - 15$ [cm/s]\\ \hline
    Sila stiska prsta & $7$ [N] \\ \hline
    \end{tabular}
    \caption{Prikaz tehničkih specifikacija Jaco robotske ruke} \label{jaco_spec}
\end{table}

\subsubsection{Aktuatori}

Manipulator se sastoji od 2 grupe od 3 identična aktuatora, modela K-75+ i K-58.
Veći aktuatori (K-75+) čine 3 donja zgloba koji podnose najveće terete, dok manji aktuatori (K-58) zauzimaju mjesto zglobova čija je primarna funkcija postavljanje orijentacije alata u prostoru.
Postoje još 3 aktuatora koji preko mehanizma arhimedovog vijka pokreću prste. 
Detaljan pregled specifikacija aktuatora nalazi se u tablicama \ref{spec_act_big}, \ref{spec_act_small}, \ref{spec_act_finger}.

\begin{figure}[h!]
\includegraphics[scale=0.5]{k75plus}
\includegraphics[scale=0.5]{k58}
\caption{a) aktuator K-75+ b) aktuator K-58}
\end{figure}

\begin{table}[h!]
    \centering
    \begin{tabular}{ | l | l | l |}
    \hline
    Masa & $0.64 \pm 2\%$ [kg] \\ \hline
    Promjer  & $74.5(+0.00/-0.03)$ [mm] \\ \hline
    Visina & $67$ [mm] \\ \hline
    Maksimalna brzina & $8$ [RPM] \\ \hline
    Apsolutna pogreška pozicije & $\pm0.5^{\circ}$ \\ \hline
    Ulazni napon  & $18 - 29$ [VDC] \\ \hline
    Nominalni moment & $15$ [Nm] \\ \hline
    Maksimalni moment & $26$  [Nm]  \\ \hline
    \end{tabular}
    \caption{Prikaz tehničkih specifikacija većih aktuatora.} \label{spec_act_big}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{ | l | l | l |}
    \hline
    Masa & $0.39 \pm 2\%$ [kg] \\ \hline
    Promjer  & $58(+0.00/-0.03)$ [mm] \\ \hline
    Visina & $69$ [mm] \\ \hline
    Maksimalna brzina & $10$ [RPM] \\ \hline
    Apsolutna pogreška pozicije & $\pm0.5^{\circ}$ \\ \hline
    Ulazni napon  & $18 - 29$ [VDC] \\ \hline
    Nominalni moment & $4$ [Nm] \\ \hline
    Maksimalni moment & $7$  [Nm]  \\ \hline
    \end{tabular}
    \caption{Prikaz tehničkih specifikacija manjih aktuatora} \label{spec_act_small}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{ | l | l | l |}
    \hline
    Maksimalna brzina & $600$ [RPM] \\ \hline
    Ulazni napon  & $18 - 29$ [VDC] \\ \hline
    Nominalni moment & $15$ [mNm] \\ \hline
    Maksimalni moment & $30$  [mNm]  \\ \hline
    \end{tabular}
    \caption{Prikaz tehničkih specifikacija aktuatora prstiju} \label{spec_act_finger}
\end{table}

\subsubsection{Senzori}
Jaco robotska ruka opremljena je velikom količinom senzora.
Svaki zglob posjeduje senzore pozicije, temperature, struje i napona.
                                                                                                                            
Senzori pozicije služe za bilježenje zakreta svakog pojedinačnog zgloba manipulatora, diferenciranjem zakreta dobivamo informaciju o brzini okretanja.
Informacijom o temperaturi aktuatora osiguravamo manipulator od moguće štete uzrokovane prekomjernim zagrijavanjem.
Pomoću senzora struje moguće je dobiti povratnu informaciju o momentu razvijenom na pojedinom aktuatoru, ovaj zaključak proizlazi iz dobro poznatog identiteta:
\begin{align}
m_m \approx k \ i_a;
\end{align}
Ovdje $i_a$ predstavlja trenutnu struju armature akturatora, dok je $k$ konstanta definirana specifikacijama motora.

%\begin{figure}[h!]
%\centering
%\includegraphics[width = 0.5\textwidth]{jaco_cad}
%\caption{Shema Kinova Jaco robotske ruke sa označenim duljinama i zakretima elemenata}
%\end{figure}

\subsection{Računalno sučelje}
Jaco robotska ruka s računalom se povezuje preko USB 2.0 (\textit{engl. Universal Serial Bus}) sučelja.
SDK\footnote{SDK (engl. Software Development Kit) - paket je programskih biblioteka, alata i uputa za razvoj vlastitih aplikacija za određeni programski ili sklopovski sustav.} Jaco robotske ruke kompatibilan je s novijim inačicama Linux Ubuntu i Windows operativnih sustava, a uz API sadrži grafičko upravljačko sučelje i bazu primjera korištenja API biblioteka.


\chapter{Programska podrška}
Ovo poglavlje sadrži opise svih programskih paketa, biblioteka i elemenata korištenih u ovom radu. 
Kratko opisujemo karakteristke i uloge svake pojedine stavke programskog dijela arhitekture sustava.
Potpoglavlja koja opisuju ROS i Gazebo sadrže nešto detaljnije opise, jer smatramo da je razumijevanje načela njihova rada ključno za razumijevanje načela rada sustava.

\section{ROS}
\begin{figure}[h!]
\centering
\includegraphics[width = 0.3\textwidth]{ros_enabled}
\caption{ROS logotip}
\end{figure}
ROS (engl. \textit{Robot Operating System}) je operacijski sustav koji omogućuje jednostavno povezivanja alata i biblioteka potrebnih za razne izvedbe u robotici. 
ROS je razvijen 2007. godine pod imenom \textit{switchyard} unutar laboratorija za umjetnu inteligenciju sveučilišta Stanford, kao razvojni alat za STAIR\footnote{\textbf{STAIR} - STanford Artificial Intelligence Robot} robota.
2008. godine razvoj ROS-a preuzima institut Willow Garage iz Kalifornije. 
Od 2013. na dalje ROS postaje potpuno open-source i razvoj preuzima Open Source Robotics Foundation.

Glavna gradivna jedinica svake izvedbe u ROS-u je paket.
Paketi u sebi sadrže C++/Python aplikacije koje nazivamo čvorovima (engl. \textit{nodes}).
Čvorove koristimo za komunikaciju s hardwareom (aktuatorima , senzorima ...), upravljanje simulacijama i prikazivanje podataka.
Izvedbe se u stvarnosti najčešće sastoje od više paketa, stoga se prava prednost ROS-a krije u ostvarivanju brze i učinkovite peer-to-peer komunikacije među čvorovima.
 
Komunikacija u ROS-u ostvaruje se mrežno (TCP/IP i UDP/IP protokolom) pomoću tema (engl. \textit{topics}) i poruka (engl. \textit{messages}).
Uz gore navedeno, ROS nudi razne naredbe unutar terminala koje olakšavaju prikaz podataka te dijagnostiku pri uklanjanju pogrešaka u kodu. Treba napomenuti da postoje i druge opcije za izvedbu aplikacija u robotici , kao što je OROCOS (engl. \textit{Open Robot Control Software} ). ROS je za ovaj projekt izabran zbog jednostavnosti izvedbe i postojećih paketa za JACO robotsku ruku.
\subsection{Osnovni koncepti}
Osnovna komunikacija u ROS-u može se vizualizirati u obliku grafa povezanih čvorova i tema. Ovakva struktura daje praktičan način prikazivanja sustava na najvišoj razini, čime se olakšava programska izvedba logike upravljanja. 

\begin{figure}[h!]
\begin{center}
\includegraphics[width=\textwidth]{ros_shema}
\caption{Čvor A i čode B ostvaruju jednosmjernu komunikaciju koristeći topic}
\end{center}
\end{figure}

Čvorovi spremaju podatke u standardizirane strukture koje zovemo porukama te ih objavljuju na odgovarajuće mrežne lokacije koje nazivamo temama. 
Svaka tema prima samo jednu točno definiranu vrstu poruke i njen sadržaj dostupan je svim čvorovima na mreži.
Izdavač (engl. \textit{publisher}) je objekt unutar čvora koji šalje poruku na temu, dok pretplatnik (engl. \textit{subscriber}) čini njegov komplement i čita poruku trenutno sadržanu na temi.

Ovaj način komunikacije omogućuje distribuciju raznih procesa na više računala što izvedbe čini manje ovisnima o sistemskim zahtjevima i izboru programskog jezika za pojedine čvorove. 
%slika streama jednog topica

\subsection{Ostale korištene funkcionalnosti}
Uz navedene osnovne funkcionalnosti , ROS sadrži neke složenije koncepte od kojih ćemo ovdje izdvojiti servise i parametarski server. 

\subsubsection{Servisi}
U ovom radu koriste se servisi (engl. \textit{services}). 
Pomoću servisa čvor A može direktno zahtijevati odgovor čvora B preko mreže. 
Čvor A objavljuje servis na mrežnu lokaciju sličnu temi, na tu lokaciju čvor B šalje zahtjev i adresu za spremanje odgovora. 
Čvor A učitava zahtjev s mrežne lokacije, obrađuje ga i odgovor sprema na adresu.

Zahtjev i odgovor najčešće su standardne ROS poruke, što znači da se pomoću servisa omogućuje korištenje funkcija čvora A u čvoru B. 
Ova funkcionalnost vrlo je korisna za distribuirane izvedbe procesno intenzivnih zadataka. 

\subsubsection{Parametarski server}
Parametrima (engl. \textit{parameters}) nazivamo karakteristične veličine unutar ROS čvorova koje se koriste pri izračunima varijabli. 
Glavna razlika između parametra i varijable nalazi se u frekvenciji promjene, koja je za parametre znatno niža. 

ROS nudi mogućnost učitavanja parametara s mrežnih lokacija čime se omogućuje jednostavno fino podešavanje ponašanja čvora pri testiranju.
Ovakvim pristupom se izbjegava potreba ponovnim kompiliranje koda pri svakoj promjeni parametara.

\subsection{ros control}
ROS paket \texttt{ros\_control}ostvaruje generičke PID regulatore za razna sklopovska sučelja unutar ROS arhitekture.
Jednostavna i standardizirana integracija s ostatkom ROS ekosustava čini ovaj paket čestom komponentom sustava izvedenih u ROS-u.

Kako bi se postiglo poopćenje PID upravljanja neovisno o konkretnom robotu (tj. o API-ju), API funkcije robota "umataju" se unutar apstraktnih \texttt{hardware\_interface} klasa koje čine ROS-API sučelje.
Umjesto da regulatori šalju i čitaju podatke koristeći API funkcije direktno, ove operacije obavljaju se pozivanjem generičkih funkcija unutar kojih su "umotane" API funkcije .
Kako bi primjenio postojeći sustav na drugog robota (uz dostupnost istog seta naredbi koje regulator koristi), korisnik mora samo uklopiti odgovarajuće API funkcije unutar generičkih.
Za dobar dio robota ovo sučelje već postoji radi open-source karaktera ROS ekosustava.

%\begin{figure}[h!]
%\centering
%\includegraphics[scale=1]{gazebo_ros_control}
%\caption{Mathworks Matlab logo}
%\end{figure}

\section{Matlab}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{logo_mathworks}
\caption{Mathworks Matlab logo}
\end{figure}
Matlab je računalno okruženje namjenjeno rješavanju širokog spektra tehničkih, računalnih i znanstvenih problema.
U užem smislu Matlab je viši programski jezik četvrte generacije koji omogućava manipulaciju matricama, numeričko računanje, iscrtavanje funkcija i još velik broj korisnih aplikacija.
Unutar Matlaba nalazi se veliki broj programskih paketa koji se koriste za specifične probleme, a nama je bitan paket za simbolički račun.
U ovom radu Matlab koristimo pri razvoju rješenja kinematike manipulatora za preliminarno testiranje matematičke provedivosti zamišljenog koncepta upravljačke petlje.

\section{OpenCV}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{logo_opencv}
\caption{OpenCV logo}
\end{figure}
OpenCV je biblioteka otvorenog koda koja je revolucionarizirala područje računalnog vida. Mnogobrojnim ugrađenim funkcijama koje su dobro dokumentirane omogućava početnicima lagani početak bavljenja računalnim vidom. U ovom radu korištene su ugrađene funkcije dostupne u biblioteci za obradu slike od kojih valja izdvojiti brze izvedbe algoritma za pronalaženje kontura na slici, određivanje obujmica kontura te implementacije morfoloških operacija nad slikom.

\section{OpenKinect/libfreenect}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{logo_openkinect}
\caption{OpenKinect logo}
\end{figure}
OpenKinect je otvorena zajednica programera entuzijasta koji su razvili biblioteku \textit{libfreenect} kao biblioteku otvorenog koda koja daje na raspolaganje sučelje za upravljanje Kinect uređajima na različitim platformama. Funkcijama za dohvat podataka s priključenog Kinect uređaja moguće je dohvatiti trenutnu dubinsku sliku u preglednom obliku koji je kompatibilan s bibliotekom OpenCV kako bi se ona mogla dalje procesirati.

\section{TensorFlow}
\textit{TensorFlow} je biblioteka otvorenog koda namjenjena brzom izračunu operacija nad podacima u obliku višedimenzionalnih tenzora. Temelji se na grafovima toka podataka gdje svaki čvor (engl. \textit{node}) u usmjerenom grafu je jedna operacija nad jednim ili više ulaznih tenzora te računa izlaz kao jedan ili više izlaznih tenzora. Većina operacija ima zna izračunati i parcijalnu derivaciju svakog izlaza po svakom od ulaza koje se koriste prilikom propagacije greške tokom učenja. 

Kako je orijentirana na strojno učenje uporabom neuronskih mreža nudi i širok spektar različitih specijaliziranih metoda, kao što su različiti optimizatori ili različiti modeli prijenosnih funkcija.

Biblioteka također omogućava lako postavljanje željene arhitekture mreže i učenje istih na grafičkim procesorima što višestruko ubrzava sam proces učenja.

\section{KDL}
KDL (engl. \textit{Kinematics Dynamics Library}) je open-source C++ biblioteka razvijena za modeliranje i računanje kinematičkih lanaca.
Pomoću ove biblioteke moguće je jednostavno programski rješavati direktnu i inverznu kinematiku te dinamiku manipulatora sa manje od 7 stupnjeva slobode.
Nama je vrlo korisna mogućnost konstrukcije Jacobijeve matrice manipulatora (definirana kasnije), koja pokazuje vrlo važnom prilikom rješavanja problema praćenja putanje u općem slučaju.
KDL također vodi računa o izbjegavanju singulariteta u matricama, čime je osiguran kontinuiran rad upravljačkog algoritma.

\section{Gazebo}
\begin{figure}[h!]
\centering
\includegraphics[scale=0.3]{gazebo_1}
\caption{Gazebo logo}
\end{figure}
Gazebo je open-source programski paket za simulaciju robotskih sustava, njihovih senzora i okoline.
Kako bi se postiglo simuliranje dinamike robota korsitimo DART\footnote{DART(engl . Dynamic Animation and Robotics Toolkit) - \texttt{www.dartsim.github.io}} , jednu od nekoliko biblioteka ovog tipa koje Gazebo podržava.
Kvalitetno iscrtavanje 3d modela korištenog robota u Gazebu je omogućeno korištenjem OGRE\footnote{OGRE(engl . Object-Oriented Graphics Rendering Engine) - \texttt{www.ogre3d.org}} 3d grafičkog modula.

Semantički opis robota, njegovih komponenti, prijenosa i zglobova Gazebo dobiva iz pripadajuće URDF\footnote{URDF(engl . Unified Robot Description Format )} datoteke.
URDF je vrlo često korišten format za opis kinematičkih lanaca koji nudi kvalitetnu integraciju u sa Gazebom i brojnim drugim robotičkim aplikacijama.
Proces pripreme simulacije znatno ubrzava činjenica da gotovo svaki komercijalni robotski manipulator ima pripadajuću URDF datoteku.

\subsection{ROS integracija Gazebo paketa}
Glavni razlog za korištenje ovog simulacijskog paketa uska je integracija sa ROS-om , čime postižemo jednostavan transfer sustava razvijenog na simulaciji na stvarni manipulator.
Gazebo simulaciju moguće je potpuno upravljati kroz ROS kroz regulatore i sučelja ostvarene \texttt{ros\_control} paketom, što nam omogućuje simuliranje korištenjem koda za stvarni manipulator.
Ova kompatibilnost ostvaruje se kroz \texttt{gazebo\_ros}, \texttt{gazebo\_msgs}, \texttt{gazebo\_plugins}  ROS pakete.
Vrstu sklopovskog sučelja simulacije definiramo unutar URDF datoteke te se pri pokretanju Gazeba unutar ROS okruženja ono objavljuje kao stvarno.
Zahvaljujući ovoj činjenici, sustav možemo razvijati za simulaciju i stvarni sustav istovremeno, što ubrzava proces razvoja.





\chapter{Kinematika manipulatora}
Modularna arhitektura našeg sustava dopušta integraciju manipulatora sa različitim razinama kompleksnosti API-ja.
Unatoč tome što većina komercijalnih manipulatora dolazi sa već izvedenim naprednim kinematičkim funkcijama, smatramo da je radi kompletnosti izvedbe bitno predviditi i slučaj kada su dostupne samo naredbe pomicanja zglobova.
Ovo poglavlje prikazuje teoretsku pozadinu programskog rješenja kinematike neredundantnog manipulatora izvedenog unutar našeg sustava na primjeru Jaco robotske ruke.
Pošto Jaco robotska ruka ima 6 stupnjeva slobode , sa stajališta složenosti kinematike ovaj izbor predstavlja svojevrsni najgori slučaj.
Kinematičko rješenje provjeravamo u Matlab programskom paketu kako bi ustanovili numeričku stabilnost rješenja i moguće nedostatke.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{kinematika}
\caption{Model Jaco robotske ruke sa označenim parametrima} \label{h}
\end{figure}

U idealnom slučaju, rješavanje problema direktne kinematike manipulatora sa do 6 stupnjeva slobode zahtjeva sintezu matrica homogene transformacije između koordinatnih sustava baze i alata.
Iz članova dobivene matrice potom analitički dobivamo izraze za Kartezijsku poziciju i orijentaciju alata u ovisnosti o zakretima zglobova.
Sintezu direktne kinematike započinjemo D-H postupkom \cite{uicker1964iterative} postavljanja koordinatnih sustava vezanih uz zglobove.
Određivanjem matrica homogenih transformacija između tih sustava dobivamo surjektivnu\footnote{Uz pretpostavku restrikcije zakreta zglobova na vrijednosti $[0,2\pi]$.} funkciju koja prostor zglobova preslikava u 6-dimenzionalni prostor pozicije.

Problem inverzne kinematike znatno je složeniji jer zahtjeva rješavanje sustava nelinearnih jednadžbi s više nepoznanica.
Za složenije manipulatore  ovaj problem je netrivijalan, a analitička rješenja postoje tek u specijalnim slučajevima gdje su osi zglobova međusobno okomite.
Još jedna otežavajuća okolnost nalazi se u činjenici da će dobivena rješenja često biti višestruka, a pronalaženje odgovarajućeg ovisi o konstrukciji i poziciji manipulatora.
Kod redundantnih manipulatora ovaj problem je još složeniji jer za svaku zadanu konfiguraciju postoji beskonačno mnogo rješenja.

Analitička rješenja problema ne postoje za većinu konfiguracija sa 6 stupnjeva slobode \cite{grochow2004style}, a klasični pristupi aproksimiranju rješenja sustava nelinearnih jednadžbi \cite{broyden1965class}\cite{bi2009three} zahtjevaju složen račun neprikladan za izvođenje u stvarnom vremenu.
Pronašli smo da je ovaj problem moguće zaobići koristeći iterativnu metodu baziranu na pronalaženju inverza matrice Jakobijana manipulatora \cite{buss2004introduction}, koja je puno prikladnija za programsku izvedbu.
\begin{figure}[h!]
\centering
\includegraphics[scale=0.35]{jacoDH1}
\caption{Model Jaco robotske ruke sa označenim parametrima korištenim pri sintezi DH parametara} \label{jacoparam}
\end{figure}

U prvom odlomku se preskaču pojedinosti D-H postupka i pomoću gotovih parametara izvodi se matrica homogene transformacije.
Drugi odlomak sadrži opis ideje rješenja inverzne kinematike osnovne postupke rješavanja kinematičkog problema na primjeru Jaco robotske ruke.
Pri tome su radi sažetosti izlaganja metode korištene u konačnom algoritmu opisane samo okvirno.
Rezultati zamišljenog postupka potom se ispituju na matematičkom modelu korištenjem Matlab programskog okruženja.

\section{Direktna i inverzna kinematika Jaco robotske ruke}\label{direkt i inverz}
\subsection{Direktna kinematika}
Problem direktne kinematike rješavamo tako da prvo postavimo koordinatne sustave koji odgovaraju svakom pojedinačnom zglobu prema pravilima D-H postupka.
Iz međusobnih udaljenosti i razlika u orijentaciji ovih zglobova porizlaze D-H parametri koje koristimo za sintezu matrica homogenih transformacija.
Množenjem dobivenih matrica dobivamo matricu koja izražava poziciju i orijentaciju alata izražene Kartezijevim koordinatama u ovisnosti o zakretu zglobova.
 
\subsubsection{DH Parametri}
Pri sintezi matrica transformacije ruke korišteni su D-H parametri iz službene dokumentacije za Jaco robotsku ruku prikazani u tablici \ref{JacoDH}. 
Za sintezu D-H parametara koristimo duljine članaka kao i parametre koji su iz njih izvedeni, prikazani su na slici \ref{jacoparam}.
Parametre $d_{4b}$, $d_{5b}$ i $d_{6b}$ određujemo iz izraza \ref{d4b}, \ref{d5b}, \ref{d6b}.

\begin{table}[h!]
    \centering
    \begin{tabular}{ | l | l | l |}
    \hline
    $D_{1}$ & $0.2755$ [m] \\ \hline
    $D_{2}$  & $0.4100$ [m] \\ \hline
    $D_{3}$  & $0.2073$ [m] \\ \hline
    $D_{4}$  & $0.0743$ [m] \\ \hline
    $D_{5}$  & $0.0743$ [m] \\ \hline
    $D_{6}$  & $0.1687$ [m] \\ \hline
    $e_{2}$  & $0.0098$ [m] \\ \hline
    $a$  & $\frac{11\cdot\pi}{72}$ [m] \\ \hline
    $d_{4b}$  & $D_{3}+D_{4}\frac{\sin(a)}{\sin(2a)}$ [m] \\ \hline
    $d_{5b}$  & $D_{4}+D_{5}\frac{\sin(a)}{\sin(2a)}$ [m] \\ \hline
    $d_{6b}$  & $D_{6}+D_{5}\frac{\sin(a)}{\sin(2a)}$ [m] \\ \hline
    \end{tabular}
    \caption{Konstrukcijski parametri Jaco robotske ruke}
\end{table}

%\begin{equation}
%d_{4b}=D_{3}+D_{4}\frac{1}{2\cdot\cos(a)}=D_{3}+D_{4}\frac{\sin(a)}{\sin(2a)}
%\label{d4b}
%\end{equation}
%\begin{equation}
%d_{5b}=D_{4}+D_{5}\frac{1}{2\cdot\cos(a)}=D_{4}+D_{5}\frac{\sin(a)}{\sin(2a)}
%\label{d5b}
%\end{equation}
%\begin{equation}
%d_{6b}=D_{6}+D_{5}\frac{1}{2\cdot\cos(a)}=D_{6}+D_{5}\frac{\sin(a)}{\sin(2a)}.
%\label{d6b}
%\end{equation}

Ne ulazeći u pojedinosti DH metode, potrebno je napomenuti da $d$ i $a$ parametri predstavljaju međusobne odmake koordinatnih sustava zglobova, dok kut $\theta$ predstavlja rotaciju koordinatnih sustava oko vlastite osi rotacije. Navedenim parametrima dodajemo i razlike u orijentaciji rotacijskih osi zglobova $\alpha$. Konačni parametri prikazani su u tablici \ref{JacoDH}.
 \begin{table}[h!]
\centering
\begin{tabular}{c c c c c}
\hline\hline
$ k $ & $ \alpha_{k} $ & $ a_{k} $ & $ d_{k} $ & $ \theta_{k} $ \\
%heading
\hline
1 & $ \pi/2 $ & $ 0 $ & $ D_{1} $ & $ \theta_{1} $\\
2 & $ \pi $ & $ D_{2} $ & 0 & $ \theta_{2} $\\
3 & $ \pi/2 $ & 0 & $ -e2 $ & $ \theta_{3} $\\
4 & $ \frac{11\pi}{36} $ & 0 & $ -d_{4b} $ & $ \theta_{4} $\\
5 & $ \frac{11\pi}{36}  $ & 0 & $ -d_{5b} $ & $ \theta_{5} $\\
6 & $ \pi $ & 0 & $ -d_{6b} $ & $ \theta_{6} $\\
\hline
\end{tabular}
\caption{DH parametri} \label{JacoDH}
\end{table}
 \begin{equation}
\theta_{1}=-q_{1_{Jaco}}
\label{q1}
\end{equation}
\begin{equation}
\theta_{2}=q_{2_{Jaco}}-\frac{\pi}{2}
\label{q2}
\end{equation}
\begin{equation}
\theta_{3}=q_{3_{Jaco}}+\frac{\pi}{2}
\label{q3}
\end{equation}
\begin{equation}
\theta_{4}=q_{4_{Jaco}}
\label{q4}
\end{equation}
\begin{equation}
\theta_{5}=q_{5_{Jaco}}-\pi
\label{q5}
\end{equation}
\begin{equation}
\theta_{6}=q_{6_{Jaco}}+\dfrac{5\cdot \pi}{9}
\label{q6}
\end{equation}

Odnos kuteva u matematičkom modelu i stvarnih kuteva zglobova Jaco ruke dan je izrazima \ref{q1}, \ref{q2}, \ref{q3}, \ref{q4}, \ref{q5}, \ref{q6}.
Varijabla $q_{i_{Jaco}}$ predstavlja trenutačnu rotaciju i-tog zgloba Jaco robotske ruke očitanu kroz API, dok $\theta_i$ predstavlja stvarni zakret i-tog zgloba.

\subsubsection{Matrice homogene transformacije}
Matrica homogene transformacije između dva koordinatna sustava postavljena prema D-H postupku određena je izrazom \ref{homogena}.
Vektor $\mathbf{p} = [x\ y\ z]^T$ sadrži poziciju ishodišta k-tog koordinatnog sustava u koordinatnom sustavu k-1.
Matrica $\mathbf{R}$ je matrica rotacije koja definira orijentaciju koordinatnog sustava k u koordinatnom sustavu k-1.
\begin{equation}
\mathbf{T_{k-1}^k} =
\begin{bmatrix} 
\mathbf{R} & \mathbf{p}\\ 
\mathbf{0} & 1\\
\end{bmatrix}
=
\begin{bmatrix} 
\cos\theta_{k}& -\cos\alpha_{k}\sin\theta_{k} & \sin\alpha_{k}\sin\theta_{k} & a_k\cos\theta_{k}\\ 
\sin\theta_{k}& \cos\alpha_{k}\cos\theta_{k} & -\sin\alpha_{k}\cos\theta_{k} & a_k\sin\theta_{k}\\
0 & \sin\alpha_{k} & \cos\alpha_{k} & d_{k}\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\label{homogena}
\end{equation}

Uvrštavajući podatke iz tablice \ref{JacoDH} u izraz \ref{homogena} dobivamo matrice homogenih transformacija za koordinatne sustave Jaco robotske ruke.
\begin{equation}
\mathbf{T_0^1} =\begin{bmatrix} \cos\theta_{1}& 0 & \sin\theta_{1} & 0\\ 
\sin\theta_{1}& 0 & -\cos\theta_{1} & 0\\
0 & 1 & 0 & d_{1}\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\end{equation}

\begin{equation}
\mathbf{T_1^2} =\begin{bmatrix} \cos\theta_{2}& \sin\theta_{2} & 0 & a_{2}\cos\theta_{2}\\ 
\sin\theta_{2}& -\cos\theta_{2} & 0 & a_{2}\sin\theta_{2}\\ 
0 & 0 & -1 & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\end{equation}

\begin{equation}
\mathbf{T_2^3} =\begin{bmatrix} \cos\theta_{3}& 0 & \sin\theta_{3} & 0\\ 
\sin\theta_{3}& 0 & -\cos\theta_{3} & 0\\
0 & 1 & 0 & d_{3}\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\end{equation}

\begin{equation}
\mathbf{T_3^4} =\begin{bmatrix} \cos\theta_{4}& -\cos\alpha_{4}\sin\theta_{4} & \sin\alpha_{4}\sin\theta_{4} & 0\\ 
\sin\theta_{4}& \cos\alpha_{4}\cos\theta_{4} & -\sin\alpha_{4}\cos\theta_{4} & 0\\
0 & \sin\alpha_{4} & \cos\alpha_{4} & d_{4}\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\end{equation}

\begin{equation}
\mathbf{T_4^5} =\begin{bmatrix} \cos\theta_{5}& -\cos\alpha_{5}\sin\theta_{5} & \sin\alpha_{5}\sin\theta_{5} & 0\\ 
\sin\theta_{5}& \cos\alpha_{5}\cos\theta_{5} & -\sin\alpha_{5}\cos\theta_{5} & 0\\
0 & \sin\alpha_{5} & \cos\alpha_{5} & d_{5}\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\end{equation}

\begin{equation}
\mathbf{T_5^6} =\begin{bmatrix} \cos\theta_{6}& \sin\theta_{6} & 0 & 0\\ 
\sin\theta_{6}& -\cos\theta_{6} & 0 & 0\\ 
0 & 0 & -1 & d_{6}\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\end{equation}

Množenjem ovih matrica dobivamo matricu homogene transformacije između baze robota i alata \ref{b-a}
\begin{equation}
\mathbf{T_{alat}^{baza}} = \mathbf{T_1^0}\ \mathbf{T_2^1}\ \mathbf{T_3^2}\ \mathbf{T_4^3}\ \mathbf{T_5^4}\ \mathbf{T_6^5}
\label{b-a}
\end{equation}

Članove ove matrice određujemo koristeći matlab skriptu, rezultat računa i skripta ispisani su u dodatku.
Iz matrice $\mathbf{T_{alat}^{baza}}$ dobivamo potpunu informaciju o položaju alata u baznom koordinatnom sustavu kao funkciju zakreta zglobova:
\begin{equation}
\mathbf{w}(\bm \theta) = 
\begin{bmatrix}
\mathbf{p}\\
\mathbf{r}(\mathbf{R})
\end{bmatrix}
\label{konfig_alat}
\end{equation}

Vektor \ref{konfig_alat} još nazivamo vektorom konfiguracije alata.

\subsection{Inverzna kinematika}
Ciljane konfiguracije izvršnog člana u $\mathbb{R}^{6}$ dane su vektorom $\vec{\mathbf{t}} = (\mathbf{t_1}, \ldots , \mathbf{t_k})^{T}$ , a trenutne konfiguracije vektorom
$\vec{\mathbf{w}} = (\mathbf{w_1}, \ldots , \mathbf{w_k})^{T}$. Kod mehaničkih manipulatora , $\vec{\mathbf{w}}$ je funkcija pozicija zglobova ${\bm{\theta}} = (\theta_{1}, \ldots , \theta_{n})^{T}$ , pa za ovaj slučaj zapisujemo $\vec{\mathbf{w}}=\vec{\mathbf{w}}\left({\vec{\bm{\theta}}}\right) $.
Problem inverzne kinematike definiramo kao pronalaženje vektora $\vec{\bm{\theta}} = (\bm{\theta_1} \ldots \bm{\theta_k})^T$ koji zadovoljava izraz:
\begin{equation}
\mathbf{t_i} = \mathbf{w_i}(\bm{\theta}_{\mathbf{i}})
\label{inverzna_def}
\end{equation}

Ono što čini problem inverzne kinematike problemom u užem smislu jest netrivijalnost rješavanja sustava jednadžbi \ref{inverzna_def} kako bi dobili $\bm{\theta}_{\mathbf{i}}(\mathbf{t_i})$. 
Razvijeni su različiti pristupi ovom problemu od kojih se mnogi oslanjaju na numeričke metode ili metode pronalaženja minimuma odgovarajuće funkcije \cite{wang1991combined}.

Korištenjem analitičke metode rješavanja opisane u uvodu ovog poglavlja, vektor $\bm{\theta}_{\mathbf{i}}(\mathbf{t_i})$ dobiva se rješavanjem sustava jednadžbi dobivenog iz vektora konfiguracije alata \ref{konfig_alat}. 
Promatrajući puni izraz za vektor konfiguracije alata $\mathbf{w}$, primjećujemo da je analitičko rješavanje ovog problema netrivijalan zadatak čije poopćavanje zahtjeva iznimno složen algoritam.
Ovo nas dovodi do zaključka da univerzalni algoritam rješavanja inverzne kinematike zahtjeva drugačiji pristup.

\section{Iterativno rješavanje kinematičkog problema}
Kako bi izbjegli komplicirano analitičko rješavanje problema inverzne kinematike, koristimo metodu koja zaobilazi rješavanje sustava jednadžbi \ref{inverzna_def}.
Prvi se korak sastoji od određivanja matrice Jakobijana manipulatora koja povezuje brzine okretanja zglobova sa linearnim i rotacijskim brzinama alata.

Pronalaženjem inverza ove matrice, moguće je odrediti potrebne brzine rotacije zglobova kako bismo ostvarili željene brzine gibanja alata.
Sintezom upravljačke petlje moguće je ostvariti praćenje referentne veličine u obliku zadanog vektora konfiguraciije alata, čime ostvarujemo iterativni postupak rješavanja inverzne kinematike.

\subsection{Jakobijan manipulatora}

Definiramo Jacobijevu matricu manipulatora kao promjenu vektora konfiguracije $\mathbf{w_i}$ u ovisnosti o promjeni $\bm{\theta}_{\mathbf{i}}$.
Radi jednostavnosti zapisa, u nastavku teksta ispuštamo indekse ovih vektora. Sada je izraz za Jacobijevu matricu:
\begin{equation}
\mathbf{J} =\frac{d\mathbf{w}}{d\bm{\theta}} \label{jakob}
\end{equation}
Počinjemo pretpostavkom da za dovoljno malene vrijednosti $\Delta \mathbf{w}$ vrijedi \ref{jac_approx}:
\begin{equation}
\Delta \mathbf{w} \approx \mathbf{J}  \Delta \bm{\theta}
\label{jac_approx}
\end{equation}
Inverzom matrice $\mathbf{J}$ možemo dobiti sljedeći vrlo koristan identitet:
\begin{equation}
\Delta \bm{\theta} \approx \mathbf{J}^{-1} \Delta \textbf{w}
\label{jac_approx2}
\end{equation}
Identitet \ref{jac_approx2} važan je jer zahvaljujući njemu ostvarujemo regulator brzine definiran u \ref{kin_upr}.

U generalnom slučaju Jacobijeva matrica predstavlja matricu dimenzija $n \times k$ gdje je $\mathbf{w_i} = (w_1, \ldots , w_k)^T$:
\begin{equation}
\mathbf{J} =
\begin{bmatrix}
    \dfrac{\partial {w_1}}{\partial \theta_{1}}      & \dfrac{\partial {w}_{1}}{\partial \theta_{2}}  & \dots & \dfrac{\partial {w}_{1}}{\partial \theta_{n}}  \\
    \dfrac{\partial{w}_{2}}{\partial \theta_{1}}      & \dfrac{\partial {w}_{2}}{\partial \theta_{2}}  & \dots & \dfrac{\partial {w}_{2}}{\partial \theta_{n}} \\
    \vdots \\
    \dfrac{\partial {w}_{k}}{\partial \theta_{1}}      & \dfrac{\partial {w}_{k}}{\partial \theta_{2}}  & \dots & \dfrac{\partial {w}_{k}}{\partial \theta_{n}}
\end{bmatrix}
\end{equation}
U slučaju kada ova matrica predstavlja prostor vektora konfiguracije $\mathbf{w}$, vrijedi $k=6$.
Ove parametre ponekad nije jednostavno analitički odrediti, stoga je korištena geometrijska metoda kojom zaobilazimo deriviranje. 
Neka je $\mathbf{p}_{j}$ pozicija j-tog zgloba u baznom koordinatnom sustavu i neka je $\mathbf{z}_{j}$ jedinični vektor osi rotacije j-tog zgloba. 
Komponente rotacijskog dijela Jakobijana $J_{\bm{\omega}_j}$ jednake su jediničnim vektorima osi rotacije zgloba u baznom koordinatnom sustavu:
\begin{equation}
J_{\bm{\omega}_j} = \dfrac{\partial \textbf{w}}{ \partial \theta_{j}} = \textbf{z}_{j}
\end{equation}
Uz pretpostavku da je rotacija mjerena u radijanima i da je smjer rotacije određen pravilom desne ruke , za translacijski dio Jakobijana $J_{\bm{v}_j}$ članovi iznose:
\begin{equation}
J_{\bm{v}_j} = \dfrac{\partial \mathbf{w}}{ \partial \theta_{j}} = \mathbf{z}_{j} \times (\mathbf{w} - \mathbf{p}_{j})
\end{equation}
U slučaju translacijskog zgloba, računanje člana još je jednostavnije jer je promjena pozicije jednaka jediničnom vektoru "osi rotacije" zgloba:
\begin{equation}
J_{\bm{v}_j} = \dfrac{\partial \mathbf{w}}{ \partial \theta_{j}} = \mathbf{z}_{j}
\end{equation}
Dobivena Jacobijeva matrica ima strukturu \ref{jacob1}, \ref{jacob2} :
\begin{equation}
\mathbf{J} =
\begin{bmatrix}
J_{\bm{v}}\\
J_{\bm{\omega}}
\end{bmatrix}
\label{jacob1}
\end{equation}

\begin{equation}
\mathbf{J} =
\begin{bmatrix}
\mathbf{z}_{0} \times (\mathbf{w} - \mathbf{p}_{0}) &\mathbf{z}_{1} \times (\mathbf{w} - \mathbf{p}_{1}) &\ldots &\mathbf{z}_{n-1} \times (\mathbf{w} - \mathbf{p}_{n-1})\\
\textbf{z}_{0} &\textbf{z}_{1} &\ldots &\textbf{z}_{n-1}\\
\end{bmatrix}
\label{jacob2}
\end{equation}
Izrazom \ref{jac_approx2} lineariziramo model gibanja robota oko točke $\bm{\theta}$. 
Uz odgovarajuću frekvenciju osvježavanja matrice $\mathbf{J}$, moguće je dobiti kvalitetnu aproksimaciju $\Delta \bm{\theta}$ za željeni $\Delta \mathbf{w}$.

Problem kod ovog pristupa nastaje u slučajevima kada matrica $\mathbf{J}$ nije kvadratna, što je slučaj kod svih manipulatora sa brojem zglobova različitim od 6.
Nekvadratnu matricu nije moguće invertirati, što znači da metoda nije univerzalna.
Radi potrebe za općim rješenjem koristimo metodu baziranu na Moore-Penroseovom pseudoinverzu \cite{klein1983review}, koji je svojevrsno poopćenje inverza matrice proizvoljnih dimenzija.
Uz određene uvjete (ref), pseudoinverz Jakobijana određujemo izrazom \ref{eq:pseudoinverz}:
\begin{equation}
\mathbf{J}^{+} = \left( \mathbf{J}^{\dagger} \mathbf{J}\right)^{-1}\mathbf{J}^{\dagger}
\label{eq:pseudoinverz}
\end{equation}
U izrazu \ref{eq:pseudoinverz} simbol $\dagger$ označava operaciju hermitske transpozicije.
Ovom modifikacijom poopćavamo ideju izraza \ref{jac_approx2} na sve manipualtore te osiguravamo veću numeričku stabilnost naspram običnog inverza.
U praksi se koriste naprednije metode koje osiguravaju dodatnu numeričku stabilizaciju dodatnim članovima, pa u praksi izraz \ref{jac_approx2} poprima oblik \ref{jacob3}.
\begin{equation}
\Delta \bm{\theta} \approx \mathbf{J}^{+} \Delta \textbf{w} + \mathbf{S}
\label{jacob3}
\end{equation}
U izrazu \ref{jacob3} matrica $\mathbf{S}$ predstavlja stabilizacijski član koji može biti ovisan o trenutnoj brzini, poziciji ili akceleraciji zglobova.
Programskom izvedba pomoću KDL biblioteka oslanja se na poboljšanu varijantu metode \ref{jacob3} zvanu metoda prigušenih najmanjih kvadrata (\textit{engl. damped least squares}) \cite{buss2005selectively}.
Za razliku od ranije navedenih metoda, ova ne traži najmanji vektor $\Delta \bm{\theta}$ koji zadovoljava \ref{jakob}.
Metoda prigušenih najmanjih kvadrata nalazi vektor $\Delta \bm{\theta}$ koji pronalazi minimum iznosa:
\begin{equation}
\|\mathbf{J}\Delta \bm{\theta} - \Delta \textbf{w}\|^2 + \lambda^2\|\Delta \bm{\theta}\|^2 \label{dlq}
\end{equation}
Izraz \ref{dlq} može se svesti na izraz \ref{dlq2}, gdje konstantu $\lambda$ odabiremo ovisno o konstrukciji manipulatora prema nekoj od razvijenih metoda (ref).
Jedan prijedlog korišten pri testiranju koncepta jest postavljanje konstante na vrijednost maksimalne dopuštene promjene vrijednosti nekog zgloba unutar jednog radnog ciklusa.
\begin{equation}
\Delta \bm{\theta} = \left(\mathbf{J}^{\dagger} \mathbf{J} + \lambda^2\mathbf{I}\right)^{-1}\mathbf{J}^{\dagger} \Delta \mathbf{w} \label{dlq2}
\end{equation}
Pokazalo se da je ovakva izvedba superiorna prema ostalim metodama, što pokazujemo u odlomku \ref{provjera}. Primjećujemo da izraz \ref{dlq2} za $\lambda = 0$ postaje \ref{jacob3}.

\subsection{Upravljačka petlja}\label{kin_upr}
%Pomoću izvedene Jakobijeve matrice manipulatora konstruiramo upravljačku petlju više razine koja regulira vektor konfiguracije alata $\mathbf{w}$.
Razmatranjem izraza \ref{jac_approx2} možemo zaključiti da smo posredno došli do metode čijom primjenom u upravljačkoj petlji u teoriji možemo ostvariti kretanje po putanji. 
Iterativnom primjenom izraza \ref{jac_approx2} moguće je ostvariti kretanje ruke prema željenom vektoru konfiguracije dokle god poznajemo pogrešku $\mathbf{e}$ . 
Za sintezu Jacobijeve matrice potrebni su nam podaci o trenutnim pozicijama zglobova $\bm{\theta}$, koji čine unutarnju povratnu vezu petlje.
Vanjsku povratnu vezu korištenu za računanje potrebne promjene vektora konfiguracije ostvarujemo pomoću bloka funkcije direktne kinematike \textbf{DK}.
Blok $\mathbf{J^{-1}}$ u ovom slučaju podrazumjeva bilo koju od metoda \ref{jac_approx2}, \ref{jacob3} ili \ref{dlq2} kojima povezujemo promjene zglobova sa promjenama vektora konfiguracije.
\begin{figure}[!h]
\centering
\begin{tikzpicture}[auto, node distance=2cm,>=latex']
    % We start by placing the blocks
    \node [input, name=input] {};
    \node [sum, right of=input] (sum) {};
    \node [block, right of=sum] (Regulator) {{$\mathbf{J^{-1}}$}};
    \node [block, right of=Regulator, node distance=3cm] (system) {{manipulator}};
    % We draw an edge between the controller and system block to 
    % calculate the coordinate u. We need it to place the measurement block. 
    \draw [->] (Regulator) -- node[name=u] {$\bm{\omega}$} (system);
    \node [output, right of=system, node distance=2cm] (output) {};
    \node [block, below of=u] (measurements1) {$\mathbf{f}$};
    \node [block, below of=measurements1] (measurements) {$\mathbf{DK}$};

    % Once the nodes are placed, connecting them is easy. 
    \draw [draw ,->] (input) -- node {$\mathbf t$} (sum);
    \draw [->] (sum) -- node {$\mathbf{e}$} (Regulator);
    \draw [->] (system) -- node [name=y] {$\bm{\theta_r}$}(output);
    \draw [->] (y) |- (measurements);
    \draw [->] (y) |- (measurements1);
    \draw [->] (measurements) -| node[pos=0.99] {$-$} 
        node [near end] {$\mathbf w$} (sum);
    \draw [->] (measurements1) -| node[pos=0.99] {} 
        node [near end] {$\bm{\theta}$} (Regulator);    
\end{tikzpicture}
\caption{Blok dijagram izvedbe upravljače petlje manipulatora} \label{petlja}
\end{figure}

Izrazom \ref{e} definiramo vektor razlike translacija u iteraciji $i$. Njime je definirana razlika u poziciji između ciljane i trenutne konfiguracije ${\mathbf{t}_{T}}$ i ${\mathbf{c}_{T}}$ unutar baznog koordinatnog sustava.
\begin{equation}
{\mathbf{e}_{T}} = {\mathbf{t}_{T}} -{\mathbf{c}_{T}}
\label{e}
\end{equation}
Kako bi potpuno definirali potrebnu promjenu konfiguracije, moramo poznavati i razliku u orijentaciji.
Također, ova mjera razlike u orijentaciji mora biti kompatibilna sa geometrijskom izvedbom Jakobijana koju koristimo u izračunima.
Ovo čini izračun nešto je složenijim, te se on ne može svesti na oduzimanje.
\begin{equation}
{\mathbf{e}_{O}} = 0.5\left(\mathbf{R}_{x_c}\times\mathbf{R}_{x_t} + \mathbf{R}_{y_c}\times\mathbf{R}_{y_t} + \mathbf{R}_{z_c}\times\mathbf{R}_{z_t}\right)
\label{eo}
\end{equation}
Koristimo izraz \ref{eo} definiran u \cite{siciliano2010robotics}, koji je pogodan za kinematičke lance koji ne posjeduju sferne zglobove.
Elementi izraza predstavljaju stupce rotacijskih matrica koji korespondiraju sa orijentacijom koordinatnog sustava koji je njima definiran.

Razliku referentnog i stvarnog vektora konfiguracije alata sustav množi se prema izrazima \ref{jac_approx2}, \ref{jacob3} ili \ref{dlq2}.
Kao rezultat množenja dobivamo potrebne zakrete zglobova $\Delta \mathbf{q}$.
Pri praćenju putanje manipulator nikad neće biti daleko od tražene pozicije, čime bez gubitka općenitosti dobivene potrebne pomake nakon skaliranja također možemo tretirati kao brzine.
\begin{equation}
\Delta \mathbf{q} \approx \bm{\omega}
\end{equation}

Vektor funkcija $\mathbf{f}$ u ovom slučaju označava preračunavanje kuteva očitanih sa manipulatora ruke $\bm{\theta_r}$ u kuteve koji odgovaraju postavljenom matematičkom modelu $\bm{\theta}$. 
Dobivene kuteve koristimo kako bi osvježili matricu $\mathbf{J}$ i kako bi dobili trenutni vektor konfiguracije alata $\mathbf{w}$. 
Iz \ref{petlja} primjećujemo kako se radi o strukturi sa P (proporcionalnim) regulatorom jediničnog pojačanja, no sustav je moguće proširiti složenijim oblicima regulatora u nadređenoj i/ili podređenoj petlji.

\subsection{Provjera sustava}\label{provjera}
Zamišljenu upravljačku shemu sustava prikazanu na slici \ref{petlja} provjeravamo u Matlabu.
Prvi korak je rješavanje direktne kinematike te generiranje funkcije \texttt{jacoFK(q)} koja kao argumente prima zakrete zglobova $\mathbf{q}$,
a kao rezultat vraća matricu homogene transformacije alata.
Sastavljamo matricu Jakobijana geometrijskom metodom u funkciji \texttt{JacoJ(q , dw)} radi boljih performansi od simboličke zamjene.
Konačno, stvaramo upravljačku petlju koja se izvodi sa proizvoljnim brojem koraka.  Uključujemo i funkciju \texttt{skaliranje} koja s obzirom na maksimalnu brzinu skalira pogrešku $e$.
\begin{algorithm}[H]
\caption{Upravljačka petlja}
\begin{algorithmic}
\STATE{\textbf{Ulaz:} $w$ -- referentni vektor konfiguracije, $q$ -- početni položaj zglobova.}
\STATE{broje koraka $:= 6$}
\STATE{$r :=$ eul2rot($w_{4-6}$)}
\FOR{($i := 0; i <$ broj koraka$; i++$)}
\STATE{$T :=$ jacoFK($q$)}
\STATE{$R := T_{1-3,1-3}$}
\STATE{$e_{1-3} := w_{1-3} - T_{1-3,4}$}
\STATE{$e_{4-6} := 0.5\left(R_x\times r_x + R_y\times r_y + R_z\times r_z\right)$}
\STATE{$e  :=$ skaliraj($e$)}
\STATE{$J :=$ jacoJ($q$,$e$)}
\STATE{$dq : = J^{-1}e$}
\STATE{$q := q + dq$}
\ENDFOR
\end{algorithmic}
\end{algorithm}
%\begin{equation}
%\alpha = atan2\left(\frac{r_{21}}{r_{11}}\right)
%\end{equation}
%\begin{equation}
%\beta = atan2\left(\frac{-r_{31}}{\sqrt{r_{32}^2 + r_{33}^2}}\right)
%\end{equation}
%\begin{equation}
%\gamma = atan2\left(\frac{r_{32}}{r_{33}}\right)
%\end{equation}
\begin{figure}[h!]
\centering
\includegraphics[width=0.49\textwidth]{matlab_pravocrtno1_kut}
\includegraphics[width=0.49\textwidth]{matlab_pravocrtno1}
\caption{Promjena pozicije inverzom Jakobijana.
Slika a) (lijevo) sadrži translacijski odziv, b) (desno) sadrži odziv orijentacije sustava u Eulerovim kutevima.} \label{P1}
\end{figure}

Radna frekvencija detekcije kreće se oko 30 Hz , a matricu Jakobijana planiramo osvježavati oko 200 puta u sekundi.
Iz ovih smjernica uzimamo kako ćemo pri testiranju osvježavati matricu Jakobijana 6 puta pri izvršavanju kretanja.
Iz grafa \ref{P1} vidljivo je kako pri čistom translacijskom kretanju upravljačka petlja sa P regulatorom ostvaruje željenu konfiguraciju  bez oscilacija u kretanju.
Kretanje koje uključuje rotacije pokazalo se nešto većim izazovom za metodu baziranu na korištenju običnog inverza Jakobijana.
\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{matlab_rot1}
\includegraphics[width = 0.49\textwidth]{matlab_rot1_xyz}
\caption{Promjena orijentacije inverzom Jakobijana.
Slika a) (lijevo) sadrži translacijski odziv, b) (desno) sadrži odziv orijentacije sustava u Eulerovim kutevima.} \label{rot1m}
\end{figure}

Sa slike \ref{rot1m} vidimo kakop pri isklučivo rotacijskom kretanju koristeći izraz \ref{jac_approx2} ne možemo dobiti zadovoljavajuće rješenje.
Ovaj slučaj jednostavan je dokaz ranije tvrdnje kako "obični" Jakobijan često nije dovoljno numerički stabilan.
Kako bi doskočili ovom problemu koristimo metodu prigušenih najmanjih kvadrata iz izraza \ref{dlq2} sa faktorom $\lambda = 0.2$.
\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{matlab_rot2}
\includegraphics[width = 0.49\textwidth]{matlab_rot2_xyz}
\caption{Promjena orijentacije metodom prigušenih najmanjih kvadrata.
Slika a) (lijevo) sadrži translacijski odziv, b) (desno) sadrži odziv orijentacije sustava u Eulerovim kutevima.} \label{rot2m}
\end{figure}

Iz slike \ref{rot2m} vidimo kako je ostvareno drastično bolje ponašanje.
Na prikazu translacije primjećujemo nakupinu crvenih indikatora u jednoj točki, što znači da je pozicija izvršnog člana približno konstantna.
Ostaje nam još ispitati ponašanje pri promjeni cijelog vektora konfiguracije.
\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{matlab_pravocrtno2}
\includegraphics[width = 0.49\textwidth]{matlab_pravocrtno2_kut}
\caption{Promjena vektora konfiguraciije metodom prigušenih najmanjih kvadrata.
Slika a) (lijevo) sadrži translacijski odziv, b) (desno) sadrži odziv orijentacije sustava predstavljene u Eulerovim kutevima.} \label{PPI}
\end{figure}

Rezultati prikazani na slici \ref{PPI} dovoljni su nam kao dokaz da se metoda prigušenih najmanjih kvadrata u teoriji može koristiti za upravljanje manipulatorom sa 6 stupnjeva slobode.
U ovom preliminarnom testiranju nismo uključivali model motora i dinamike manipulatora i stoga će konačnu programsku izvedbu biti potrebno testirati na simulaciji.

%Klasičnim PID regulatorom možemo značajno smanjiti oscilatornost sustava.
%Pošto se regulator izvodi u kodu, potrebno ga je ostvariti rekurzivno:
%\begin{equation}
%\mathbf{u}(i)  = K_I\mathbf{u}(i-1) + K_D[\mathbf{e}(i) - \mathbf{e}(i-1)] + K_P\mathbf{e}(i)
%\end{equation}
%
%Parametriranje regulatora ostvarujemo pomoću optimizacije kriterijske funkcije \ref{krit} koja kažnjava oscilatornost i vrijeme potrebno za postizanje stacionarnog stanja.
%\begin{equation}
%crit(k) = crit(k-1) + 100 k (\mathbf{t} - \mathbf{w}(k)) (\mathbf{t} - \mathbf{w}(k))^T
%\label{krit}
%\end{equation}
%
%Kako bi pronašli parametre $K_I$ i $K_P$ kojima ostvarujemo minimum ove funkcije koristimo Matlab funkciju \verb|fminsearch|.
%Potrebno je uzeti u obzir činjenicu da u ovom procesu nismo modelirali ponašanje samih elektromotora u zglobovima jer pretpostavljamo da su kvalitetno regulirani od strane FPGA pločice na manipulatoru.
%Ovi parametri također ovise o Jakobijanu korištenog manipulatora i raznim mehaničkim karakteristikama, ali rezultati optimiranja mogu poslužiti kao dobra polazna točka pri sintezi regulatora.

\chapter{Detekcijski algoritam}\label{Detekcijski algoritam}
Postoje mnogobrojni načini kojima se može upravljati pokretima ruke. U ovom radu koristi se dubinska kamera koja omogućuje snimanje pokreta ljudske ruke, a zatim se svaka snimljena slika prevodi u informaciju. Tako dobivena informacija govori o trenutnoj lokaciji i orijentaciji ruke u trodimenzionalnom prostoru promatranom dubinskom kamerom.

Problem detekcije položaja ruke relativno uspješno je riješen i kod klasičnih slika (npr. \cite{de2011model}, \cite{stenger2001model} ili \cite{rehg1994visual}), ali je taj pristup obilježen prevelikom ovisnošću o svjetlosnim parametrima slike te potrebom za većim računalnim resursima. Takvi zahtjevi uvelike otežavaju detekciju u stvarnom vremenu na osobnom računalu.

U detekciji objekata kod dubinske slike, prikladna je većina pristupa detekciji objekata kao kod klasične slike s intenzitetom svjetlosti u pojedinim točkama. Pri tome dubinsku sliku možemo promatrati kao klasičnu sivu sliku te raditi detekcije nad istom, ali ne smijemo zaboraviti da informacija koju sadrži pojedini slikovni element ne odgovara intenzitetu, već je mjera udaljenosti. Također uobičajena crno-bijela slika se sastoji od 8-bitnih vrijednosti što polučuje 256 različitih slikovnih elemenata te u velikom broju slučajeva možemo biti zadovoljni s tim. Za razliku od uobičajene crno-bijele slike, kod dubinske slike sa 256 različitih slikovnih elemenata sposobni smo detektirati 256 različitih dubina, što nije dovoljno ukoliko želimo detekciju na većem rasponu ($1m$) uz veliku preciznost ($1mm$). Stoga je u slučaju dubinske slike uobičajen zapis pomoću 2 okteta ili broja s jednostrukom preciznosti po IEEE 754 standardu. Ovaj potonji zapis kompatibilan je s korištenom OpenCV bibliotekom.

Razvijeni detekcijski algoritam podijeljen je u dvije slijedne komponente. Lokalizacija dlana u slici te određivanje parametara položaja u kojem se dlan nalazi.

\section{Lokalizacija dlana u slici}
Određivanje lokacije ruke na dubinskoj slici je kao i kod klasičnih slika, prvi korak u preciznom detektiranju pložaja u kojem se ruka nalazi. Postoje mnogobrojne metode koje omogućuju rješavanje takvog problema, ali vrlo rijetko se nalazi metoda koja ne koristi neki oblik pomagala kako bi se što lakše i brže odredila lokacija ruke na dubinskoj slici. Tako se više vremena može posvetiti samom određivanju položaja u kojem se ruka nalazi.

S obzirom da uvođenjem dodatnih dimenzija slike povećavamo kompleksnost sustava, takvi pokušaji su zanemareni, ali valja spomenuti kako se filtriranjem isključivo boje kože može olakšati pretraga ruke. Neki od takvih pristupa koriste brzu detekciju lica i stvaranje uzoraka parametara boje kože detektirane osobe u svrhu poboljšavanja filtera boje pomoću dobivenih parametara.

\subsection{Slične metode}
Qian i suradnici razvili su jednu od najkvalitetnijih metoda danas \cite{qian2014realtime}. Metoda inicijalno pretpostavlja kako se ruka nalazi najbliže kameri u odnosu na ostale objekte u dubinskoj slici. Također, pretpostavlja korištenje nereflektirajuće narukvice na zapešću kojom se lako može izolirati ruka od okoline algoritmom poplavljivanja interesnog područja (eng. \textit{flood fill}).

Bolja inicijalna metoda preuzeta je iz rada Shottona i suradnika \cite{shotton2013real} u kojem detektiraju položaj čovjeka na dubinskoj slici. Implementirano prepoznavanje ljudskog kostura pomoću Kinect uređaja temelji se na njihovoj metodi. Tu inicijalnu metodu koriste Thompson i suradnici \cite{tompson2014real}. Metoda koristi jednostavne značajke $f_{\theta}(I,\mathbf{x})$ za svaki slikovni element $\mathbf{x}$ koje su invarijantne na dubinu $d_{I}(\mathbf{x}) $ (Izraz \ref{eq:depth_invariant_feature}).
\begin{equation}\label{eq:depth_invariant_feature}
f_{\theta}(I,\mathbf{x})=d_{I}(\mathbf{x}+ \frac{\mathbf{u}}{d_{I}(\mathbf{x})})-d_{I}(\mathbf{x}+ \frac{\mathbf{v}}{d_{I}(\mathbf{x})})\end{equation}
Dalje za svaki slikovni element $\mathbf{x}$ učenjem šume nasumičnih stabala odluke (eng. \textit{random decision forrest}) odredi se svega nekoliko parova odmaka $(\mathbf{u},\mathbf{v})$ koji dobro binarno klasificiraju svaki slikovni element pripada li on naučenom skupu objekata ili ne.

Grupiranjem slikovnih elemenata koji su imali pozitivan odziv klasifikatora možemo izolirati ruku ili više njih na dubinskoj slici.

Iako je metoda uspješna i relativno brza, pogotovo na grafičkoj kartici za koju je primarno namijenjena, u slučaju ovog završnog rada nedostatak takve metode bilo bi trajanje njenog učenja. Naime, autori navode kako na klasteru od 1000 jezgara učenje šume od 3 stabla do dubine 20 traje 1 dan, a uzevši u obzir nedostatak navedenih resursa, takav pristup u ovom radu nije moguć.

\subsection{Razvijena metoda}

Dubinska slika kakvu stvara korištena dubinska kamera je veličine 640x480 slikovnih elemenata. Pri tome vrijednost svakog slikovnog elementa odgovara izračunatom disparitetu na toj poziciji. Pomoću \textit{freenect} biblioteke takav podatak se može pretvoriti u dubinu u milimetrima.

Definiran je koordinatni sustav sa središtem u očištu kamere i osima $x$ i $y$ s odgovarajućim indeksom $(u+320,v+240)$ slikovnog elementa (kako bi središte koordinatnog sustava pomakli u središte slike). Osi x i y su skalirane na odmak od središta u milimetrima. Os z odgovara dubini slike također u milimetrima. Prirodom perspektivne projekcije kakvu daje dubinska kamera udaljenost od kamere ne odgovara udaljenosti do projekcijske ravnine. Samim tim se ne može izravno preslikati u z-os koordinatnog sustava, ali kako dlan na radnim udaljenostima ne zauzima više od 15\% slike na tom području je aproksimacija prihvatljiva.

Jedna od mogućih aproksimativnih formula za preslikavanje dispariteta u udaljenost od kamere, kakvu koristi \textit{freenect} biblioteka \cite{openkinect} je sljedeća (Izraz \ref{eq:approx_raw_disparity_to_mm}):
\begin{equation}
	\label{eq:approx_raw_disparity_to_mm}
	z_{d}(\mathbf{x})=\frac{1000}{-0.00307*d(\mathbf{x})+3.33}
\end{equation}
Dobivenim vrijednostima dubine možemo izračunati $x$ i $y$ vrijednosti koordinantnog sustava na sljedeći način:
\begin{equation}
	\label{eq:raw_disparity_to_mm_x}
	    x(z,u)=0.0021(v - 320)(z-10) 
\end{equation}
\begin{equation}
	\label{eq:raw_disparity_to_mm_y}
	    y(z,v)=0.0021(v - 240)(z-10)
\end{equation}
Kao i kod metode Qiana i suradnika \cite{qian2014realtime}, ali i mnogih drugih, i u ovom radu se pretpostavlja kako se ruka nalazi na najmanjoj dubini (niti jedan predmet u vidnom polju kamere nije bliži od ruke).

Za razliku od spomenute metode, u ostvarenoj metodi nije potrebno koristiti pomagala kao što je nereflektirajuća crna narukvica na zapešću. Izolacija dlana od okoline vrši se jednostavnim dubinskim filterom na empirijski određenoj dubini od $110mm$ u odnosu na globalni minimum dubine slike, što je ujedno i globalni minimum dijela slike na kojem se nalazi ruka. Iako najveći raspon prosječne ruke premašuje $110mm$, to ne predstavlja prevelik problem.
\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{detekcija/izolacija-ispravno-1}
\includegraphics[width = 0.49\textwidth]{detekcija/izolacija-ispravno-2}
\includegraphics[width = 0.49\textwidth]{detekcija/izolacija-ispravno-3}
\includegraphics[width = 0.49\textwidth]{detekcija/izolacija-ispravno-4}
\caption{Uspješno izoliranje dlana na slici. 
Slika (a) (lijevo gore) predstavlja izoliranje uspravnog dlana, 
slika (b) (desno gore) izoliranje dorzalne strane dlana,
slika (c) (lijevo dolje) izoliranje dlana u vodoravnoj ravnini,
slika (d) (desno dolje) izoliranje šake} \label{successful_palm_isolation}
\end{figure}

Na slikama \ref{successful_palm_isolation} vidimo primjere ispravne izolacije dlana na dubinskoj slici. Radilo se o uspravnom dlanu (a), dlanu s dorzalne strane (b), pa čak dlanu u vodoravnoj ravnini (c) ili zatvorenom dlanu (d), ovakav jednostavni detektor je sposoban razlučiti dlan kako bi što više procesnog vremena mogao prepustiti sljedećim fazama detekcije.
\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{detekcija/izolacija-zadovoljavajuce-1}
\includegraphics[width = 0.49\textwidth]{detekcija/izolacija-zadovoljavajuce-2}
\caption{Prihvatljivo izoliranje dlana na slici. 
Slika (a) (lijevo gore) predstavlja izostavljanje karpalnog predjela dlana, 
slika (b) (desno gore) zahvaćena podlaktica} \label{satisfactorily_palm_isolation}
\end{figure}

U nekim slučajevima detekcija nije ispravna, ali je u granicama otpornosti kasnijih faza detektora. Tako se pri većim kutovima dlana u odnosu na projekcijsku ravninu mogu desiti dva slučaja (Slika \ref{satisfactorily_palm_isolation}). Ako je najbliža točka dlana na području zapešća, zahvaćen je i dio podlaktice, dok ako je najbliža točka na području prstiju, dlan djelomično izlazi iz granica dubinskog filtera.

\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{detekcija/izolacija-krivo-1}
\caption{Pogrešna izolacija dlana, zahvaćen i dio podlaktice} \label{poor_palm_isolation}
\end{figure}

Oba slučaja većinom ne predstavljaju prevelik problem, no postoje i neke iznimke. Naime, ako je podlaktica u razini dlana, detektor neće biti sposoban razlučiti dlan od podlaktice (Slika \ref{poor_palm_isolation}). Takav slučaj predstavlja problem za detektor, ali takav slučaj ne predstavlja problem u korištenju detektora ako je osoba koja ga koristi svjesna takvog nedostatka.

Rezultat izolacije dlana uz sliku na kojoj se nalazi samo dlan je i $(x,y,z)$ koordinata središta dlana u prostoru. Središte je dobiveno pronalaskom konture dlana te izlučivanjem njenog središta. Prije pronalaska konture na binarnoj slici se izvodi morfološka operacija zatvaranja s jezgrom veličine u radijusu od 2 susjedna slikovna elementa (Manhattan udaljenost). U slučaju da je središte konture izvan konture pa samim time i dlana, takva detekcija biva odbačena. Iako postoje položaji ruke gdje je to slučaj, takve položaje u većini slučajeva Kinect nije sposoban registrirati (Poglavlje \ref{sec:kinect_depth}).

Jednom kada je dlan segmentiran od pozadine znatno se olakšavaju daljnje operacije. Za razliku od spomenutih naprednijih radova ovdje se neće razmatrati određivanje precizne lokacije ruke u vidu modela od više od 20 stupnjeva slobode. Naime, uzevši u obzir primjenu detektora za upravljanje robotskom rukom, prihvatljiva doza informacije sastoji se od binarne informacije o stupnju zatvorenosti dlana i radij vektora lokacije dlana te eventualno orijentacija dlana u smjeru x-osi definiranog koordinatnog sustava.

Neki od ključnih postupaka u detekciji izvedeni su pomoću biblioteke OpenCV:
\begin{enumerate}[label=$\bullet$]
	\item \textbf{Segmentacija slike na osnovu praga} je postupak prilikom kojeg se s obzirom na željenu vrijednost praga može konstruirati binarna slika (maska) gdje jedna vrijednost pokriva sve elemente čija je vrijednost ispod praga, a druga vrijednost sve elemente iznad praga. Na slici \ref{image_segmentation} (b) vidimo binarnu sliku dobivenu segmentacijom po dubini slike (a) pri čemu je prag određen kao $110mm$ u dubinu od minimalne vrijednosti dubine na slici.

\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{detekcija/mask-image}
\includegraphics[width = 0.49\textwidth]{detekcija/mask-mask}
\caption{Segmentacija slike na osnovu praga, lijevo ulazna dubinska slika i desno generirana maska} \label{image_segmentation}
\end{figure}	

\item \textbf{Dilatacija i erozija binarne slike} su morfološke transformacije. Dilatacija je transformacija prilikom koje se generira nova slika iste veličine. Za svaki osvijetljeni slikovni element u početnoj slici se u ovoj slici osvjetljava element na toj lokaciji zajedno s $n$ slikovnih elemenata u njegovoj okolini. Takvim postupkom smo povećali osvijetljene površine na slici. Erozija je slična dilataciji s razlikom što se postupak temelji na neosvijetljenim slikovnim elementima.

Na slici \ref{morph_transform} (c) je prikazana morfološka transformacija izvorne slike (a) operacijom zatvaranja (dilatacija pa erozija) uz djelovanje na okolnih 8 slikovnih elemenata. Kao što vidimo ovakav slijed transformacija pokriva moguće šumove unutar osvijetljenog dijela slike te može spojiti bliske skupine osvijetljenih slikovnih elemenata što je korisno ako na primjer šum \textit{odsiječe} prst od ostatka ruke.

\begin{figure}[h!]
\centering
\includegraphics[width = 0.32\textwidth]{detekcija/before}
\includegraphics[width = 0.32\textwidth]{detekcija/after_dilate}
\includegraphics[width = 0.32\textwidth]{detekcija/after_erode}
\caption{Morfološka transformacija binarne slike operacijom zatvaranja, s lijeva na desno ulazna slika, međukorak te slika nakon transfomracije} \label{morph_transform}
\end{figure}

\item \textbf{Određivanje obujmica} skupina osvijetljenih slikovnih elemenata koristan je način za aproksimaciju oblika na slici. Prvi korak u određivanju obujmica (engl. \textit{convex hull}) je generiranje kontura oko skupina susjednih slikovnih elemenata. Jednom kada je kontura izgenerirana jednostavno se može naći obujmica kao minimalan konveksan poligon koji obuhvaća konturu.

Na slici \ref{convex_hull} je običnoj binarnoj slici sivom bojom pridodana razlika u površini konture oblika i obujmice. Ta razlika se može iskoristiti kao dobar indikator zatvorenosti dlana.

\begin{figure}[h!]
\centering
\includegraphics[width = 0.49\textwidth]{detekcija/obujmica}
\caption{Obujmica i kontura ruke na slici} \label{convex_hull}
\end{figure}

\end{enumerate}

\newpage
\section{Određivanje poze dlana}

\subsection{Slične metode}
Različiti radovi predlažu različite metode određivanja poze u kojoj se nalazi ruka, ali i u različitom opsegu preciznosti.

Qian i suradnici u svom radu \cite{qian2014realtime} su modelirali prosječnu ruku pomoću 48 sfera uz 26 stupnjeva slobode. Pretražuju ekstreme u području dlana te im oni služe kao kandidati za vrhove prstiju i zapešće. Pomoću inverzne kinematike nad modelom generiraju moguće položaje ruke te svaki od njih ocjenjuju s obzirom na sličnost s dubinskom slikom. Najbolji model je proglašen trenutnim položajem ruke.

Thompson i suradnici u svojem radu \cite{tompson2014real} koriste naučenu kaskadu konvolucijskih neuronskih mreža. Učenje je izvršeno na 70 000 označenih slika. Mreže na izlazu daju dvodimenzionalnu Gaussovu razdiobu vjerojatnosti da se na određenoj lokaciji nalazi jedna od 36 označenih lokacija na ruci (npr. vrh malog prsta). I u ovom radu inverznom kinematikom se traži model ruke koji najviše odgovara razdiobama. Pri tome je rabljen često korišten model ruke otvorenog koda \textit{libhand} \cite{libhand}.

Valja napomenuti kako su navedene metode sposobne prepoznati ruku u jednoj dubinskoj slici te im ne treba niz slika.

\subsection{Razvijena brza metoda određivanja zatvorenosti dlana} \label{brza-metoda}
Zatvorenost dlana je apstraktan pojam te ga treba pobliže definirati. Prilično je intuitivan pojam otvoreni dlan koji predstavlja dlan u planarnom položaju, pri čemu kutevi između članaka teže nuli (Slika \ref{fig:successful_palm_isolation} a). Isto tako je jasan je pojam zatvorenog dlana (Slika \ref{fig:successful_palm_isolation} d). Teško je pak definirati stupanj zatvorenosti prilikom neke geste, pri kojoj dlan nije ni potpuno otvoren ni zatvoren, pogotovo ako je svaki prst pod svojim kutom. Tako se u ovom radu stupanj zatvorenosti određuje binarno pri čemu \textit{0} predstavlja zatvoren dlan, a \textit{1} sve ostale položaje.

Navedeni pristup sasvim je dovoljan pri kontroli željenog robota jer takav klasifikator nam određuje hoće li se prsti robotske ruke skupiti ili ne. Naime, iako robot posjeduje prste, nezgrapno bi bilo odrediti parametar zatvorenosti za svaki prst kako broj robotskih prstiju (3) ne korespondira broju ljudskih.

Klasifikator je napravljen jednostavno i empirijski. Izračuna se površina binarne slike zahvaćena konturom dlana ($ P_{k}(\mathbf{s}) $) i površina obujmice iste konture ($ P_{o}(\mathbf{s}) $). Generira se značajka koja predstavlja omjer površine konture i obujmice (\ref{eq:closure_feature_1}).
\begin{equation}\label{eq:closure_feature_1}
f_{1}(\mathbf{s})=\frac{P_{k}(\mathbf{s})}{ P_{o}(\mathbf{s})} 
\end{equation}
Potom se normalizira površina konture kako bi bila invarijantna na dubinu te se ista tretira kao druga značajka (\ref{eq:closure_feature_2}).
\begin{equation}\label{eq:closure_feature_2}
f_{2}(\mathbf{s})={P_{k}}'(\mathbf{s}) 
\end{equation}
Određivanje zatvorenosti dlana vrši se određivanjem predznaka linearne kombinacije dvije navedene značajke te još ostaje samo odrediti parametre $k$ i $l$ (\ref{eq:closure_}).
\begin{equation}\label{eq:closure_}
Z(\mathbf{s})=\left\{\begin{matrix}
 1&  ako&kf_{1}(\mathbf{s})+lf_{2}(\mathbf{s})>0\\
 0& ako & kf_{1}(\mathbf{s})+lf_{2}(\mathbf{s})\leq 0
\end{matrix}\right.
\end{equation}
\subsubsection{Učenje klasifikatora}
Nakon što su definirane značajke, generirano je 2559 ispitnih primjera od kojih 1239 s otvorenim dlanom i 1320 sa zatvorenim dlanom. Grafikon \ref{scatter_graph_lbl} prikazuje točke koje predstavljaju slike u ravnini određenoj značajkama $f_{1}$ i $f_{2}$ s time da zatvoreni dlanovi su prikazani zelenom bojom, a otvoreni crvenom.

\begin{figure}[h!]
\label{scatter_graph_lbl}
\centering
\input{scatter_graph}
\renewcommand{\figurename}{Grafikon}
	\caption{Skup za učenje (crveno - slike zatvorenih dlanova, zeleno - slike otvorenih dlanova)}
\end{figure}

U ravnini značajki grafičkom metodom je aproksimiran pravac koji razdvaja dvije klase, zatvorene i otvorene dlanove s greškom od 3.4\%. Težilo se preciznijoj detekciji zatvorenog dlana, što je uzrokovalo gubitak u preciznosti detekcije otvorenog dlana. Takav pristup je vođen pretpostavkom da prilikom upravljanja robotskom rukom zatvoreni dlan podrazumijeva kako ruka drži neki objekt te želimo biti sigurni kako ga neće olako ispustiti bez naše volje. Iako za neki teži problem ovakav pristup detekciji otvorenosti dlana ne bi bio dobar te bismo se trebali okrenuti naprednijim metodama, u ovom slučaju rezultat je sasvim zadovoljavajuć s obzirom na poprilično jasnu distinkciju između dviju klasa.

Dobiveni pravac ima parametre $k = 0.67635$ i $l=0.035558$ koji se koriste u detektoru prilikom određivanja zatvorenosti dlana.

\subsubsection{Rezultati}
\label{sec:tuning}
Posjedovanjem slijednih slika možemo ublažiti utjecaje mogućih oscilacija na detekciju.

Prilikom određivanja zatvorenosti dlana dobivena vrijednost omjera (Izraz \ref{eq:closure_feature_1}) se sprema u vektor koji sadrži prethodnih $ n $  omjera iz prethodnih $n$ slika te se u pojedinom trenutku $t$ vrijednost može odrediti pomoću težinskog prosjeka vrijednosti u vektoru.
\begin{equation}\label{eq:advanced_closure_feature}
F_{1}(\mathbf{s}(t))=\sum_{0}^{n-1} w_{i}f_{z}(\mathbf{s}(t-i))
\end{equation}
Iako inicijalno je razmatrana mogućnost Gaussove raspodjele težina ($w_{i}$), ipak dovoljno dobrim klasifikatorom se iskazala aritmetička sredina zadnjih $n=7$ slika. Sasvim analogno se pristupa s drugom značajkom (Izraz \ref{eq:closure_feature_2}).

Ispitana je brzina pojedine detekcije detektora. Ako izuzmemo vrijeme koje je potrebno Kinectu da dostavi sliku, vrijeme detekcije implementacije detektora neoptimiziranom Python skriptom je $(7.7 \pm 1.6) ms$ ispitano na procesoru porodice \textit{Intel Core i5}. Takva brza detekcija posljedica je jednostavne metode koji ne sadrži računski zahtjevne algoritme. Kako je Kinect u mogućnosti generirati oko 25 slika u sekundi, a algoritam radi brzinom većom od 125 slika u sekundi, postoji veliki prostor za nadogradnju mogućnosti algoritma.

Ispitivanje točnosti detektora može se izvesti na dva načina. Kako detektor vrši detekciju na jednoj slici, a koristi slijedne slike za ispravak mogućih nepravilnosti može se očekivati da će u slijednim slikama detektor raditi bolje.

Uz pretpostavku da se dlan nalazi na najbližoj dubini u slici promatrati uspješnost detekcije lokacije dlana bi se svelo na promatranje uspješnosti dubinske kamere u određivanju dubinske slike o čemu ovdje neće biti riječ.

Preostaje nam ispitati klasifikator zatvorenosti dlana. U oba slučaja vršit će se ispitivanje nad istim slikama s time da će u slučaju slijednih slika značajke ovisiti i o prethodnim slikama (vidi \ref{sec:tuning}).

Ispitivanje je vršeno na 3108 slika od kojih 1323 s otvorenim dlanom i 1785  sa zatvorenim dlanom. U oba slučaja se ispitivao udio ispravno određenih slika. Kako je klasifikator binarni, udio lažno pozitivnih slika zatvorenog dlana biti će jednak udjelu lažno negativnih slika otvorenog dlana i obrnuto. Za razliku od učenja koje je provođeno na jednoj osobi, u ispitivanju su sudjelovale tri osobe.
\begin{figure}[h]
\centering
\begin{tabular}{ l || c c || r }
	& Ispravno  & Neispravnih &Ukupno\\\hline
	Broj primjeraka & 1203 & 120 &1323\\
	Udio&90.9\%&9.1\%
\end{tabular}
\renewcommand{\figurename}{Tablica}
	\caption{Rezultati ispitivanja klasifikacije otvorenog dlana u pojedinoj slici}
	\label{fig:single_img_open}
\end{figure}
\begin{figure}[h]
\centering
\begin{tabular}{ l || c c || r }
	& Ispravno  & Neispravnih &Ukupno\\\hline
	Broj primjeraka & 1728 & 57 &1785\\
	Udio&96.8\%&3.2\%
\end{tabular}
\renewcommand{\figurename}{Tablica}
	\caption{Rezultati ispitivanja klasifikacije zatvorenog dlana u pojedinoj slici}
	\label{fig:single_img_close}
\end{figure}
\begin{figure}[h]
\centering
\begin{tabular}{ l || c c || r }
	& Ispravno  & Neispravnih &Ukupno\\\hline
	Broj primjeraka & 1256 & 67 &1323\\
	Udio&94.9\%&5.1\%
\end{tabular}
\renewcommand{\figurename}{Tablica}
	\caption{Rezultati ispitivanja klasifikacije otvorenog dlana u slijednim slikama}
	\label{fig:multi_img_open}
\end{figure}
\begin{figure}[h]
\centering
\begin{tabular}{ l || c c || r }
	& Ispravno  & Neispravnih &Ukupno\\\hline
	Broj primjeraka & 1740 & 45 &1785\\
	Udio&97.5\%&2.5\%
\end{tabular}
\renewcommand{\figurename}{Tablica}
	\caption{Rezultati ispitivanja klasifikacije zatvorenog dlana u slijednim slikama}
	\label{fig:multi_img_close}
\end{figure}
\clearpage
\paragraph{Rezultati ispitivanja detekcija u pojedinoj slici}\mbox{}\\
U slučaju ispitivanja klasifikacije otvorenog dlana (Tablica \ref{fig:single_img_open}) klasifikator je uspio ispravno prepoznati otvoreni dlan u 90.9\% slučajeva, dok je kod klasifikacije zatvorenog dlana (Tablica \ref{fig:single_img_close}) zatvoreni dlan uspješno prepoznat u 96.8\% slučajeva što je zadovoljavajući rezultat.
\paragraph{Rezultati ispitivanja detekcija u slijednim slikama}\mbox{}\\
U slučaju ispitivanja klasifikacije otvorenog dlana (Tablica \ref{fig:multi_img_open}) klasifikator je uspio ispravno prepoznati otvoreni dlan u 94.9\% slučajeva, dok je kod klasifikacije zatvorenog dlana (Tablica \ref{fig:multi_img_close}) uspio prepoznati zatvoreni dlan u 97.5\% slučajeva što je zadovoljavajući rezultat.
\paragraph{Usporedba ispitivanja}\mbox{}\\
Kao što se može primijetiti, klasifikator je bolji u detekciji zatvorenih dlanova i u slijednim slikama i u pojedinoj slici, što je i bio cilj modeliranja klasifikatora, ali se isto može objasniti i time da zatvoreni dlan izgleda poprilično jednako iz bilo kojeg kuta, što nije slučaj za otvoreni dlan.\\\\
Isto tako, ispitivanjem je potvrđena opravdanost korištenja informacija iz prethodnih slika kojima se može znatno poboljšati detekcija smanjenjem oscilacija uprosječivanjem vremenski susjednih detekcija. U našim primjerima je postignuto smanjenje neispravnih detekcija u rasponu od 1.3 do čak 2 puta. 

\newpage
\subsection{Razvijena metoda primjenom dubokih konvolucijskih neuronskih mreža}

Inicijalna estimacija lokacije dlana u slici ne traje dugo te daljnja procjena poze dlana može trajati puno duže. Već i gore navedena brza metoda određivanja zatvorenosti dlana i na najslabijim uređajima ostavlja poprilično procesorsko vrijeme neiskorišteno. Odlučeno je dakle iskoristiti do tada neiskorišteno procesorsko vrijeme kako bi detektor dao bolji opis poze u kojoj se dlan nalazi.

\subsubsection{Prikupljanje podataka}
Prethodna metoda se temelji na jednostavnim, ali vrlo uspješnim heuristikama. Ipak, za opisivanje poze dlana s više parametara takav pristup je puno zahtjevniji. Jedan od alternativnih skupova pristupa su tzv. pristupi vođeni samim podacima (engl. \textit{data-driven approach}). Za takav pristup valja prikupiti dovoljnu količinu željenih (u konkretnom slučaju i označenih) podataka te nad njima naučiti model. Model bi opisivao pozu dlana koji mu je predan kao slika na ulazu.

U nedostatku bolje opreme (konkretno žiroskopa kakav se nalazi u većini mobilnih uređaja) koja bi omogućila brže i preciznije prikupljanje željenih podataka s detaljnijim opisom poze dlana, valjalo je osmisliti efikasan način prikupljanja što većeg broja raznovrsnih podataka uz njihovo precizno označavanje.

Klasifikator poze ima dva izlaza. Prvi određuje stupanj otvorenosti dlana kao i u prethodnoj metodi, dok drugi određuje rotaciju dlana oko x osi. Takva rotacija omogućuje robotskoj ruci da uhvati nešto iznad, ispred ili ispod dlana te zbog toga je odabrana kao najkorisnija u usporedbi s rotacijama oko y ili z osi. Podaci su prikupljani u 15 različitih klasa kao kartezijev produkt tri stupnja zatvorenosti dlana $ (0,0.5,1)$ te 5 različitih rotacija oko x osi $(-90\deg, -45\deg, 0\deg, 45\deg, 90\deg)$. Kada bismo u istu proceduru uključili i druge dvije rotacije, tada bi ukupan broj klasa bio $3\cdot5\cdot5\cdot5 =375$ što uz dane resurse ne bi bilo izvedivo.

\begin{figure}[h!]
\centering
\includegraphics[width = 1.0\textwidth]{detekcija/dataset}
\caption{Neki od prikupljenih označenih podataka} \label{covnet-dataset}
\end{figure}

Ukupno je prikupljeno $61 395$ označenih slika dlana podijeljenih u 3 skupa (učenje, validacija i ispitivanje) u omjeru $8:1:1$. Prikupljene slike su dubinske slike dlana dobivenog detekcijom segmentirane na osnovu praga opisanog u postupku detekcije te binarizirane tako da slikovni elementi dlana imaju vrijednost $1$, a ostali $0$ (slika \ref{covnet-dataset}).

Razlog binarizaciji i segmentaciji leži u tome što pri učenju modela želimo reducirati količinu informacija koje klasifikator dobiva na ulaz u postupku učenja kako ih ne bi prenaučio. Naime, uklanjanjem pozadine klasifikator neće biti opterećen time što je u pozadini dlana već morati naučiti heuristike isključivo temeljem slikovnih elemenata dlana. Također, iz sličnog razloga ne želimo klasifikatoru pružiti informaciju na kojoj udaljenosti se dlan nalazio u datoj slici kako se ne bi oslonio i na tu informaciju.


\subsubsection{Arhitektura}\label{arhitektura-mreze}
Oformljena konvolucijska mreža na ulazu prima binariziranu sliku dimenzija $64\times64\times1$ te na izlazu generira dva vektora. Prvi vektor je trodimenzionalni i opisuje zatvorenost dlana kako je opisano, dok drugi je peterodimenzionalni i opisuje orijentaciju. Vrijednosti odgovaraju vjerojatnosti s kojom ulazna slika pripada određenoj klasi. 

Takav diskretiziran izlaz se dalje pretvara u dvije vrijednosti, postotak zatvorenosti dlana i orijentaciju dlana kao broj između $0$ i $1$ gdje $0$ odgovara dlanu s vidljivom palmarnom stranom dlana dok $1$ pri vidljivoj dorzalnoj strani dlana prilikom rotacije oko x osi definiranog sustava.

Korištena konvolucijska mreža sastoji se od 5 konvolucijskih slojeva s filterom veličine $3\times3$ slikovnih elemenata i $16$ kanala, a iza svakog osim prvog slijedi podotipkavajući sloj s filterom veličine $2\times2$ koji smanjuje dimenzionalnost ulaznog tenzora na četvrtinu njegove inicijalne veličine uzimanjem maksimalne vrijednosti u pojedinim oknima (engl. \textit{maxpool}). Za prijenosnu funkciju u svakom sloju korištena je ispravljena linearna funkcija (engl. \textit{rectified linear unit}) oblika:

$$f(x) = max(0,x)$$

Tako je na predzadnjem sloju dobivena reprezentacija slike pomoću tenzora veličine $4\times4\times16$ koji se izravnava (engl. \textit{flatten}) u $256$ dimenzionalni vektor dobivenih značajki. Takve značajke su dalje jednim potpuno povezanim slojem povezane s gore navedenim izlazom neuronske mreže.

Učenje mreže provodi se algoritmom unazadne propagacije gradijenata (engl. \textit{backpropagation}) pri čemu se za grešku koristi težinski zbroj unakrsnih entropija softmax funkcije izlaza za pojedinu klasu (engl. \textit{softmax cross entropy loss}).

Također, radi sprečavanja prenaučivanja modela, u funkciju gubitka pridodan je i L2 gubitak učenih težina

U implementaciji neuronske mreže korištena je bibiloteka \textit{TensorFlow}. Učenje je trajalo 3 sata na grafičkoj kartici \textit{Nvidia GeForce 840M} pri čemu bi se pri svakoj stagnaciji faktora učenja on smanjivao 3 puta.

\subsubsection{Rezultati}
Dobiveni rezultati prikazani su na slijedećoj tablici:
\begin{table}[h!]
    \centering
    \begin{tabular}{ | l  l  l  l |}
    \hline
Vrsta skupa & Točnost otvorenosti & Točnost orijentacije & Ukupna točnost \\ \hline
    Skup za učenje & $99.8\%$&$99.2\%$&$98.9\%$\\
    Skup za validaciju &$97.1\%$&$94.5\%$&$92.1\%$\\
    Skup za ispitivanje & $97.0\%$&$94.6\%$&$92.2\%$\\ \hline
    \end{tabular}
    \caption{Prikaz točnosti naučene konvolucijske mreže} \label{rezultati-mreze}
\end{table}

Kao što se vidi u tablici \ref{rezultati-mreze} ukupna točnost mreže prelazi 92\% prilikom klasifikacije na pojedinačnoj slici. Klasifikacija se dodatno poboljšava uprosječavanjem zadnjih $7$ slika dubinske kamere, kao i u odlomku \ref{brza-metoda} te tako točnost raste na 96\%. Kao što je bilo i očekivano, klasifikacija otvorenosti dlana je puno lakši problem od orijentacije te u pojedinačnim slikama je dobivena točnost od 97\%.

Za vizualizaciju dobivenih visokodimenzionalnih podataka korištena je dobro poznata metoda redukcije dimenzionalnosti t-SNE \ref{van2008visualizing} pomoću koje je vizualiziran izlaz zadnjeg potpuno povezanog sloja neuronske mreže. Metoda pokušava očuvati euklidsku udaljenost između vektora u višedimenzionalnom prostoru pri prenošenju u nižedimenzionalni prostor (u ovom slučaju dvije dimenzije). Metoda je iterativna te pokušava minimizirati pogrešku euklidske udaljenosti među primjerima.

Pretpostavka dobro naučenog modela je ta da na toj razini je mreža dovoljno dobro naučena da obični linearni višeklasni klasifikator može razdvojiti primjere. To ne znači nužno da u t-SNE vizualizaciji će primjeri biti linearno odvojivi već kako se primjeri istih klasa nalaze na međusobno relativno bliskoj udaljenosti.

\begin{figure}[h!]
\centering
\includegraphics[width = 1.0\textwidth]{detekcija/train_otvorenost}
\caption{Vizualizacija izlaza zadnjeg potpuno povezanog sloja neuronske mreže metodom t-SNE nad svim podacima za učenje grupiranih po označenoj otvorenosti.} \label{tsne-otvorenost}
\end{figure}

Na grafu \ref{tsne-otvorenost} možemo primjetiti kako su većinom primjeri dobro grupirani, a najviše odskaču primjeri za poluotvoren dlan što se i moglo pretpostaviti s obzirom kako je ona najlošije definirana klasa, kao nešto između otvorenog i zatvorenog dlana.

\begin{figure}[h!]
\centering
\includegraphics[width = 1.0\textwidth]{detekcija/train_kut}
\caption{Vizualizacija izlaza zadnjeg potpuno povezanog sloja neuronske mreže metodom t-SNE nad svim podacima za učenje grupiranih po označenom kutu dlana.} \label{tsne-kut}
\end{figure}

Pojava okluzije u dubinskoj slici oslabljuje kvalitetu detekcije malih površina te tako dlan postavljen u xz ravninu definiranog koordinatnog sustava je zahtjevno detektirati pa time i klasificirati. Ipak mreža je uspjela i takav problem rješiti te je zanimljivo promotriti t-SNE prikaz obojan po klasama orijentacije dlana (graf \ref{tsne-kut}) gdje vidimo kako su primjeri horizontalno postavljenog dlana (zeleno) relativno udaljeni od primjera vertikalno postavljenog dlana te da između njih se nalaze klase dlana pod kutem od $45$ i $-45$ stupnjeva u odnosu na horizontalu što namo može ukazati na to da je mreža naučila interpolirati između horizontalnog i vertikalnog dlana. Time je opravdano interpoliranje izlaza neuronske mreže kako je opisano u prethodnom odlomku (\ref{arhitektura-mreze}).


\begin{figure}[h!]
\centering
\includegraphics[width = 1.0\textwidth]{detekcija/train_all}
\caption{Vizualizacija izlaza zadnjeg potpuno povezanog sloja neuronske mreže metodom t-SNE nad svim podacima za učenje.} \label{tsne-all}
\end{figure}

Zanimljivo je pogledati i brojnost nakupina istovjetnih klasa na grafovima \ref{tsne-kut} i \ref{tsne-otvorenost}, gdje u oba slučaja neke klase imaju više udaljenih nakupina iako pripadaju istoj klasi. Graf \ref{tsne-all} kao kartezijev produkt oba elementa klasfikacije (otvorenost i orijentacija) može ponuditi objašnjenje tog naizgled problema. Naime, na izlazu mreže mogu se pojaviti 15 različitih slučajeva, koji su u grafu prikazani različitim bojama. Može se primjetiti kako primjeri istih elemenata kartezijevi produkta klasa zauzimaju puno kompaktinij prostor nego gledajući svaki element klasifikacije zasebno.

Ovakvom analizom možemo zaključiti kako će se najveće greške prilikom klasifikacije dešavati u području horizontalnog dlana što i ja bilo za očekivati s obzirom na lošu kvalitetu ulazne slike u takvim pozama zbog okluzija.

Neuronska mreža dobivena ovakvim postupkom sposobna je klasificirati ~1200 slika u sekundi na gore navedenoj grafičkoj kartici, a 160 slika u sekundi na procesoru porodice \textit{Intel Core i7}. U svakom slučaju klasifikacija će i na slabijim današnjim procesorima raditi u stvarnom vremenu, što je i bio cilj.

\chapter{Upravljački algoritam}\label{Upravljački algoritam}
Ovo poglavlje pomoću koncepata i metoda objašnjenih u prethodnim poglavljima možemo detaljno prikazuje arhitekturu upravljačkog dijela sustava.
U odlomku \ref{arhitektura} opisujemo korake potrebne za inicijalizaciju sustava te detalje sklopovskih sučelja, glavnog čvora i kinematičkih izračuna.
Odlomak \ref{simuliranje} sadrži opis simulacijskih ispitaivanja odrađenih na sustavu i njihove rezultate.
Rezultate zatim komentiramo i objašnjavamo njihov odraz na stvarni sustav.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{upr_shema}
\caption{Upravljačka shema}\label{upr_shm}
\end{figure}

Na slici \ref{upr_shm} prikazana je detaljna shema sustava u programskoj izvedbi.
Iscrtkani pravokutnik predstavlja granicu između uređaja i računala dok žuti i sivi predstavljaju područje sustava unutar ROS, odnosno \texttt{ros\_control}arhitekture, respektivno.


\section{Arhitektura upravljačke petlje}\label{arhitektura}
Ulazni signal u sustav dolazi iz detekcijskog algoritma u obliku ROS poruke \verb|ime poruke| čija je struktura :
Kako bi ostvarili mogućnost udaljenog upravljanja, detekcijski dio ostvarujemo kao zasebni ROS čvor koji frekvencijom 30 Hz objavljuje poruke na temu \verb|ime topica|.
Ovime omogućujemo pokretanje detekcijskog algoritma na zasebnom računalu, uz uvjet da je na istoj mreži kao ostatak ROS čvorova.

Glavni čvor svaku novu poruku \verb|ime topica| čita i obrađuje.
Početnoj poziciji korisnikovog dlana (pri prvoj detekciji) pridružuje se željena pozicija manipulatora jednaka početnoj.
Pomak dlana od početne pozicije primljen u poruci sustav zbraja s početnom pozicijom manipulatora koju smo ranije spremili, čime dobivamo novu željenu poziciju manipulatora.
Trenutna pozicija manipulatora potom je oduzeta od željene, čime dobivamo nama bitnu potrebnu translaciju manipulatora.
Zbog ograničenja pri detekciji orijentacije dlana, trenutnu orijentaciju (klasificiranu u diskretne slučajeve) direktno prenosimo u željenu orijentaciju manipulatora.

\begin{algorithm}[H]
\caption{Računanje potrebne promjene vektora konfiguracije}
\begin{algorithmic}
\STATE{\textbf{Ulaz:} P -- odmak dlana od početne pozicije \\ R -- diskretna orijentacija \\ M -- početni vektor konfiguracije manipulatora \\ T -- trenutni vektor konfiguracije manipulatora.}
\STATE{\textbf{Izlaz:} E -- potrebna promjena vektora konfiguracije.}
\FOR{($i := 0; i < 6; i++$)}
\IF{($i<3$)}
\STATE{$nova_i := M_i + P_i$} 
\ENDIF
\IF{($i>=3$)}
\STATE{$nova_i := M_i + R_i$} 
\ENDIF
\STATE{$E_i = nova_i - T_i$}
\ENDFOR
\end{algorithmic}
\end{algorithm}

Vektor $E_i$ predstavlja \textit{vektor razlike konfiguracija} i koristi se u daljnjim koracima algoritma, koji se ovisno o dostupnim naredbama konfigurira u dva različita oblika.
Prvi oblik se koristi pri dostupnoj naredbi Kartezijske brzine izvršnog člana, kojom možemo direktno narediti kretanje po x,y i z osima koordinatnog sustava baze.
Drugi oblik koristi se ako je dostupno postavljanje brzine zglobova, što ga čini složenijim.

\subsection{Inicijalizacija sustava}
Prvi korak pri inicijalizaciji sustava sastoji se od pokretanja sklopovskih sučelja.
Samo sučelje jest programska rutina koji ostvarujemo tako da API funkcije manipulatora "umotavamo" u \verb|hardware_interface| klasu koja je dio \texttt{ros\_control}paketa.
Pri pokretanju cijelokupnog sustava , sučelje se pokreće prvo i čini granicu između algoritama i naredbi koje direktno pokreću manipulator.

\subsubsection{Sučelje brzine izvršnog člana}
U slučaju dostupnosti sklopovskog sučelja koje dopušta direktno postavljanje kartezijske brzine, algoritam se znatno pojednostavljuje.
Na ovaj način izbjegavamo složen kinematički račun iz poglavlja \ref{direkt i inverz} i oslanjamo se na interne algoritme samog manipulatora.

Pri primanju poruke tipa \texttt{ime\_poruke} sa detekcijskog servera, funkcija \\  \texttt{sendCartesianCommand} unutar glavnog čvora obrađuje podatke. 
Vektor razlike konfiguracija sklairamo za neki iznos $\alpha$, ali daljnju regulaciju ostavljamo upravljačkom algoritmu samog manipulatora.
Ovo znači da \texttt{ros\_control} u ovom obliku koristimo isključivo za prosljeđivanje naredbi te čitanje stanja zglobova.
Po završetku obrade, Kartezijska naredba šalje se u obliku poruke \verb|ime_2| na temu \verb|goal|, koja je rezervirana za referentnu veličinu kretanja manipulatora.
Naredba vezana uz izvršni član sprema se u poruku \verb|ime_3| te se šalje na temu \verb|goal_2|, koja je rezervirana za referentnu veličinu operacije izvršnog člana te ima vlastiti regulator.

Pokazalo se da je ovaj pristup optimalan za brzi početak korištenja jer visoka radna frekvencija najčešće znači da se parametar $\alpha$ može postaviti proizvoljno, dok ostalu regulaciju provodi API.

\subsubsection{Sučelje brzine/pozicije zglobova}
Nakon inicijalizacije, sučelje registrira pojedinačne zglobove i "spaja" se na naredbe pisanja i čitanja stanja zglobova.
Ovo spajanje vrši se tako da se spomenuti API naredbe umataju u funkcije čiji su pokazivači dostupni  odgovarajućim \texttt{ros\_control}regulatorima.
Važno je spomenuti da svaki regulator ima odgovarajuću podvrstu \texttt{hardware\_interface} klase i neće se spajati na neodgovarajuća sučelja.

Sljedeći korak je inicijalizacija sučelja, pokreće se regulator tipa \texttt{velocity\_ controllers/JointGroupVelocityController}. 
Regulator svoje parametre učitava iz odgovarajuće konfiguracijske YAML\footnote{YAML (engl. YAML Ain't Markup Language) - \texttt{www.yaml.org}} datoteke.
U parametre između ostalog ubrajamo imena robota i zglobova, tip sučelja, pojačanja P, I i D komponenti, vremenska ograničenja na izvršenje naredbi, ograničenja zglobova i frekvenciju.
Pokretanjem regulatora API naredbe manipulatora činimo mrežnim resursima unutar ROS "grafa", čime ovaj dio sustava postaje potpuno fizički odvojiv od ostatka.
Svi podaci sa senzora postaju dostupni na temi \verb|joint_states|, postavljanje referentne veličine vrši se slanjem odgovarajuće poruke na temu \verb|\goal|, a parametri regulatora također su dostupni.

\subsection{Glavni čvor}
Inicijalizacijom glavnog čvora dovršavamo pokretanje sustava.
Dok \texttt{ros\_control} regulator osigurava stabilnu brzinu, glavni čvor čini nadređenu regulacijsku petlju koja osigurava odgovarajuću referentnu veličinu baziranu na razlici željenog i trenutnog vektora konfiguracija.
Kako bi rješili problem kinematike opisan u poglavlju \ref{direkt i inverz}, pomoću metoda dostupnih u KDL bibliotekama učitavamo opis kinematičkog lanca iz \texttt{.urdf} datoteke.
Iz učitanog se lanca pomoću funkcija u klasi \texttt{Kinematics} generira matrica direktne kinematike i Jakobijan sustava. 
Nakon toga poziva se funkcija koja obavlja množenje pseudoinverza jakobijana traženom promjenom vektora konfiguracija način sličan \ref{jac_approx2}, pri tome dodajući članove koji osiguravaju numeričku stabilnost.
Konačno, inicijaliziraju se odgovarajući ros pretplatnici i izdavači te sustav postaje spreman za uporabu.

Sada pri primanju nove naredbe iz kinecta sustav obrađuje ulazne podatke kao što je opisano na početku poglavlja.
Dobiveni vektor razlike konfiguracije se pomoću funkcija \texttt{Kinematics} klase pretvara u vektor pogreške pozicije zglobova.
Pogreške pozicija zglobova tretiraju se kao željene brzine zglobova, ali ih je prvo potrebno skalirati s obzirom na maksimalnu dozvoljenu brzinu.
Ograničenja brzina upisana su u YAML datoteku koja se učitava pri pokretanju regulatora te ih \texttt{ros\_control} stavlja na mrežne lokacije koje glavni čvor čita i sprema u varijable.
Brzine je vrlo bitno skalirati na način kojim se zadržava njihov omjer, stoga prvo pronalazimo brzinu koja najviše prelazi ograničenje te sve brzine skaliramo prema njoj.
\begin{algorithm}[H]
\caption{Skaliranje brzina}
\begin{algorithmic}
\STATE{\textbf{Ulaz:} V -- brzine bez ograničenja, O -- ograničenja brzine.}
\STATE{\textbf{Izlaz:} Vs -- skalirane brzine.}
\STATE{$m := 0$}
\FOR{($i := 0; i < broj zglobova; i++$)}
\IF{$|V_i| > O_i \ \& \ \|V_i-O_i\| > m$)}
\STATE{$m := \|V_i-O_i\|$}
\STATE{$i_m := i$}
\ENDIF
\ENDFOR
\STATE{$s = O_{i_m}/V_{i_m}$}
\FOR{($i := 0; i < broj zglobova; i++$)}
\STATE{$Vs_i := V_i*s$}
\ENDFOR
\end{algorithmic}
\end{algorithm}

Visoka vrijednost akceleracije zglobova može uzrokovati oscilacije u kretanju pri određenim položajima. 
Akceleracije ograničavamo skaliranjem, na sličan način kao kod brzina.
Pri ograničavanju potrebno je voditi računa o frekvenciji glavnog čvora jer se brzine osvježavaju 50 puta u sekundi te se male razlike pri svakom taktu mogu pretvoriti u veliku razliku.
\begin{algorithm}[H]
\caption{Skaliranje brzina s obzirom na akceleraciju}
\begin{algorithmic}
\STATE{\textbf{Ulaz:} V -- brzine bez ograničenja, Vt -- trenutna brzina,  A -- ograničenja akceleracije.}
\STATE{\textbf{Izlaz:} Vs -- skalirane brzine.}
\STATE{$m := 0$}
\FOR{($i := 0; i < broj zglobova; i++$)}
\IF{$\|V_i - Vt_i\| > A_i \ \& \ \|V_i - Vt_i\| > m $)}
\STATE{$m := \|V_i - Vt_i\|$}
\STATE{$i_m = i$}
\ENDIF
\ENDFOR
\STATE{$s = A_{i_m}/m$}
\FOR{($i := 0; i < broj zglobova; i++$)}
\STATE{$Vs_i := V_i*s$}
\ENDFOR
\end{algorithmic}
\end{algorithm}

Nakon ovih skaliranja referentna brzina spremna je za slanje na temu koju čita regulator brzine zglobova.
U slučaju sučelja pozicije zglobova, ovu veličinu možemo smatrati pomakom te je dodati trenutnim vrijednostima zakreta zglobova kako bi dobili željenu poziciju.
Vrijednosti vezane uz izvršni član neovisne su o sučelju i šalju se direktno.

\subsection{Kinematika}
Biblioteka KDL nije jedina, a vjerojatno ni najkvalitetnija dostupna metoda rješavanja općeg kinematičkog problema.
Kako bi ostavili prostora za kvalitetnijeg nasljednika ili moguće vlastite implementacije naprednijih metoda, kinematiku smo odvojili u diskretnu komponentu sustava.
Kao što je ranije spomenuto, sve funkcije vezane uz kinematičke kalkulacije sadržane su u  \texttt{Kinematics} klasi.

Pri inicijalizaciji kalse unutar glavnog čvora prvo je potrebno konstruirati kinematički lanac od semantičkog opisa sadržanog u URDF datoteci.
Čitanje se obavlja tako da pri pokretanju sustava datoteku učitavamo u ROS parametar \texttt{robot\_description}, koji klasa pri inicijalizaciji dohvaća i sprema kao varijablu tipa \texttt{string}.
Ovaj opis zatim parsiramo pomoću KDL funkcije  \texttt{treeFromString} koja od opisa generira kinematičko stablo tipa \texttt{Tree}.
Kinematički lanac koji opisuje manipulator iz stabla dohvaćamo pomoću funkcije \texttt{getChain} i spremamo u varijablu tipa \texttt{Chain}.

Pomću kinematičkog lanca inicijaliziramo kalsu \texttt{ChainFkSolverPos\_recur\-sive}, koja iz zakreta zglobova pomoću funkcije \texttt{JntToCart} daje poziciju izvršnog člana u koordinatnom sustavu baze.
Za kalkulacije potrebnih brzina zglobova inicijaliziramo klasu \texttt{ChainIkSolverVel\_wdls}.
Pri pozivu funkcije \texttt{CartToJnt} generira Jakobijan te računa izraz sličan \ref{jac_approx2}, uz određena poopćenja i osiguravanje numeričke stabilnosti (ref).
Funkcija \texttt{getFK} sadrži proceduru za rješavanje direktne kinematike, dok \texttt{getIKvel} sadrži računa vezan uz dobivanje potrebnih pomaka zglobova.

Poznavajući teorijsku pozadinu iza ovakvog sustava, vlastita implementacija algoritma također je moguća.
Unatoč tome, za KDL biblioteke odlučili smo se radi već rješenih tehničkih problema kao što su upravljanje memorijom i optimiranje performansi.
Sustav mora vršiti izračune relativno visokom frekvencijom i stoga bilo kakvo \textit{curenje} memorije može ostaviti trag na performansama.

\section{Simuliranje sustava}\label{simuliranje}
Ispravnost sustava bilo je potrebno testirati na simulaciji kako pri stvarnoj primjeni ne bi došlo do oštećenja korištenog manipulatora.
Za postizanje simulacije manipulatora koristili smo Gazebo programski paket.

Kao što je prije spomenuto, Gazebo ima ugrađenu kompatibilnost sa \texttt{ros\_control} paketom te nudi opciju stvaranja "lažnog" sklopovskog sučelja za simulaciju.
Velika prednost Gazeba leži upravo u navedenoj kompatibilnosti jer pri simuliranju možemo koristiti identičan kod kao i za stvarni manipulator.
Ovakvim pristupom znatno smanjujemo vrijeme potrebno za testiranje jer uočene probleme ne moramo popravljati na dvije različite varijante koda.

Simuliramo Jaco robotsku ruku, čija URDF datoteka sadrži i definirana sučelja zglobova te 3d modele koje korespondiraju pojedinim člancima.
Ovakve opise možemo pronaći za većinu komercijalnih manipulatora, stoga je testiranje na isti način moguće vršiti i na drugim modelima.
U simulaciju također uključujemo dinamičko ponašanje ruke jer opisna datoteka također sadrži tenzore inercije pojedinih članaka.
Pri pokretanju, Gazebo automatski generira sklopovsko sučelje prema podacima iz opisa i inicijalizira regulator.
Za inicijalizaciju sustava koristimo iste korake kao i prije, pri tome isključujući korak inicijalizacije sklopovskog sučelja za stvarni manipulator.
%\begin{figure}[h!]
%\centering
%\includegraphics[width=0.5\textwidth]{gazebo1}
%\caption{Prikaz modela Jaco robotske ruke unutar Gazebo okruženja.}
%\end{figure}

Testiranje provodimo zadajući kružne, isključivo translacijske putanje koje manipulator treba periodički izvoditi.
Prva putanja prostire se samo u yz-ravnini te bi se u idealnom slučaju trebalo događati samo dvodimenzionalno kretanje.
\begin{figure}[h!]
\centering
\includegraphics[width=0.49\textwidth]{xz_krug}
\includegraphics[width=0.49\textwidth]{yz_krug}
\caption{Prikaz zadane putanje u yz-ravnini (crveno) i njene izvedbe (plavo). \textbf{Lijevo}: prikaz u xz-ravnini, \textbf{Desno}: prikaz u yz-ravnini.} \label{krug_1}
\end{figure}
Na slici \ref{krug_1} primjećujemo kako za planarno gibanje model ima naočigled zadovoljavajuće preformanse.
Prikaz u xz-ravnini otkriva kako ostvarujemo skoro savršeno kružnu putanju. Greška u stacionarnom stanju uzrokovana je relativno malim promjerom kruga čija zakrivljenost zahtjeva veliku brzinu sustizanja.
Na prikazu gibanja u yz-ravnini primjećujemo odstupanja reda veličine manjeg od milimetra koja ne predstavljaju problem jer industrijski precizno kretanje nije ciljana karakteristika našeg sustava.
\begin{figure}[h!]
\centering
\includegraphics[width=0.49\textwidth]{xz_krug2}
\includegraphics[width=0.49\textwidth]{yz_krug2}
\caption{Prikaz zadane putanje u xz-ravnini (crveno) i njene izvedbe (plavo). \textbf{Lijevo}: prikaz u xz-ravnini, \textbf{Desno}: prikaz u yz-ravnini.} \label{krug_2}
\end{figure}
Postavljamo krug duž xz-ravnine i zabilježavamo rezultate na slici \ref{krug_2}.
Rezultati su slični kao i kod slučaja sa slike \ref{krug_1}, te su pogreške u praćenju zanemarive kada uzmemo u obzir zamišljene aplikacije sustava.
U praksi zadana putanja nikada neće biti planarna, stoga zadajemo putanju u obliku kružnice postavljene dijagonalno u prostoru.
\begin{figure}[h!]
\centering
\includegraphics[width=0.53\textwidth]{xyz_krug3}
\caption{Prikaz zadane prostorne putanje  (crveno) i njene izvedbe (plavo) u Kartezijevom koordinatnom sustavu.} \label{krug_3}
\end{figure}

Putanja sa slike \ref{krug_3} zahtjeva kretanje po sve 3 osi i predstavlja izazov za stabilnost algoritma.
Iz rezultata možemo zaključiti kako je u općem slučaju pri translacijskom gibanju po neprekinutoj krivulji kinematičko rješenje zadovoljavajuće.
Potrebno je uzeti u obzir da je kružna putanja najpogodnija za izvedbu manipulatorima, dok će u praksi putanje često sadržavati nagle promjene smjera.

Pravokutne ili isprekidane putanje mogu predstavljati izazov jer savršeno pravocrtno gibanje manipulatora u praksi nije moguće.
U većini slučajeva linearne se putanje uspješno izvode sa određenom pogreškom pri promjeni nagloj promjeni smjera.
Na slici \ref{pravokutnik} lijevo primjećujemo kako je pravokutno gibanje ostvareno sa pogreškom pri skretanju reda veličine milimetra.
Ovo je očekivano višestruko veća pogreška od one dobivene gibanjem po kružnici, ali i dalje potpuno prihvatljiva s obzirom na primjenu.
\begin{figure}[h!]
\centering
\includegraphics[width=0.49\textwidth]{xyz_pravokutnik2}
\includegraphics[width=0.49\textwidth]{xyz_pravokutnik}
\includegraphics[width=0.47\textwidth]{konf1}
\includegraphics[width=0.47\textwidth]{konf2}
\caption{Prikaz izvedbe iste putanje sa dvije različite početne konfiguracije. Gornji red sadrži željenu (crveno) i izvedenu (plavo)  putanju .
Donji red sadrži prikaz početne konfiguracije putanje iznad.} \label{pravokutnik}
\end{figure}
%\begin{figure}[h!]
%\centering
%\includegraphics[width=0.49\textwidth]{konf1}
%\includegraphics[width=0.49\textwidth]{konf2}
%\caption{Prikaz zadane prostorne putanje  (crveno) i njene izvedbe (plavo) u Kartezijevom koordinatnom sustavu.} \label{pravokutnik}
%\end{figure}

Na slici \ref{pravokutnik} desno vidimo izvođenje iste putanje pri drugačijoj početnoj konfiguraciji manipulatora.
Rezultat je očito drastično lošiji jer se na dijelu putanje pojavljuju značajne oscilacije koje uzrokuju oscilatorno gibanje i pogrešku u praćenju.
Ovo je posljedica činjenice da manipulatori imaju tzv. singularne konfiguracije u kojima Jacobijeva matrica manipulatora nije regularna te se efektivno gubi stupanj slobode.
U ovakvim konfiguracijama male kartezijske promjene zahtjevaju neizvedivo brze rotacije zglobova, čime sustav postaje nestabilan.

Metoda provođenja kinematičkog računa unutar KDL biblioteka "ublažava" singularitete tako da spriječava ulazak vrijednosti u beskonačnost te osigurava kontinuiran rad sustava.
Pronalazak svih singularnih konfiguracija u slučaju metode prigušenih najmanjih kvadrata zahtjeva pronalaženje svih zakreta zglobova koji zadovoljavaju identitet \ref{singularity}:
\begin{equation}
\det \mathbf{\mathbf{J}^{\dagger} \mathbf{J}} = \mathbf{0} \label{singularity}
\end{equation}

Iako pronalaženje svih jedinstvenih rješenja ovog identiteta programski nije pretjerano složeno, izbjegavanje ovakvih konfiguracija složeniji je problem.
Potrebno je izvesti algoritam zaobilaženja kritičnih konfiguracije (u općem slučaju) na način da se ne gubi smjer kretanja.
Ovo zahtjeva dublje ulaženje u problematiku i veliku količinu testiranja te za sada moguća oscilatorna stanja prihvaćamo kao nedostatak sustava.


\chapter{Rezultati}


\chapter{Rasprava}
\chapter{Zaključak}
\bibliography{literatura}
\bibliographystyle{fer}
\begin{sazetak}
U ovom radu razvijena je metoda upravljanja robotskim manipulatorom baziranu na imitiranju pokreta ljudske ruke. Pokrete i lokacija ruke korisnika detektirana je koristeći 3-d kameru i vlastite algoritme bazirane na strojnom učenju. Algoritam za detekciju dlana razvijen je za uporabu u stvarnom vremenu i postižemo dvije efikasne varijante. Sustav je zamišljen kao univerzalan i modularan, što ga čini primjenjivim na velikom broju manipulatora uz minimalne modifikacije. Pretpostavljen je manipulator bez ugrađenih naprednih kinematičkih funkcija, te se istražuje problematika rješavanja kinematike manipulatora u općem slučaju. Dobiveni sustav upravljanja prvo se ispituje na simulaciji Jaco robotske ruke, a potom i na stvarnoj robotskoj ruci iste vrste. Rezultati se izlažu u obliku slika, grafova i videozapisa. Komentira se intuitivnost sustava i kvaliteta praćenja korisnikovih kretnji.
\end{sazetak}

\begin{abstract}
In this paper we present a method of controlling robotic manipulators based on mirroring movement of the human hand. Movement and location of the arm are detected using a 3-d camera and internally developed algorithms based on machine learning. The proposed method is developed as universal and modular, allowing use on a large number of robotic manipulators. We assume a manipulator without provided advanced kinematics functions and reasearch methods of solving manipulator kinematics in the general case. The resulting contol system is then tested on a simulation of the Jaco robotic arm and subsequently on the real Jaco arm itself. Results presented in the form of pictures, graphs and video are analized for quality of control and simplicity of use.
\end{abstract}
\end{document}
